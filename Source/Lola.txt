---
GlobalUsings.cs
// Global using directives
global using System.ComponentModel;
global using System.ComponentModel.DataAnnotations;
global using System.Linq.Expressions;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using System.Security.Cryptography;
global using System.Text;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox;
global using DotNetToolbox.AI.Agents;
global using DotNetToolbox.AI.Anthropic;
global using DotNetToolbox.AI.Jobs;
global using DotNetToolbox.AI.OpenAI;
global using DotNetToolbox.AI.Personas;
global using DotNetToolbox.ConsoleApplication;
global using DotNetToolbox.ConsoleApplication.Application;
global using DotNetToolbox.ConsoleApplication.Commands;
global using DotNetToolbox.ConsoleApplication.Nodes;
global using DotNetToolbox.Data.DataSources;
global using DotNetToolbox.Data.File;
global using DotNetToolbox.Data.Storages;
global using DotNetToolbox.Domain.Models;
global using DotNetToolbox.Environment;
global using DotNetToolbox.Results;

global using Lola;
global using Lola.Commands;
global using Lola.Jobs.Commands;
global using Lola.Jobs.Handlers;
global using Lola.Jobs.Repositories;
global using Lola.Main.Commands;
global using Lola.Models.Commands;
global using Lola.Models.Handlers;
global using Lola.Models.Repositories;
global using Lola.Personas.Commands;
global using Lola.Personas.Handlers;
global using Lola.Personas.Repositories;
global using Lola.Providers.Commands;
global using Lola.Providers.Handlers;
global using Lola.Providers.Repositories;
global using Lola.UserProfile.Commands;
global using Lola.UserProfile.Handlers;
global using Lola.UserProfile.Repositories;
global using Lola.Utilities;
global using Lola.Utilities.HttpConnection.Handlers;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Options;

global using Serilog;

global using Spectre.Console;

global using static System.Ensure;

---
LolaSettings.cs
namespace Lola;

public class LolaSettings
    : ApplicationSettings {
    public string DefaultAIProvider { get; set; } = string.Empty;
    public string[] AvailableModels { get; set; } = [];
    public string CurrentAgentKey { get; set; } = string.Empty;
}

---
LolaShellApplication.cs
namespace Lola;

public class LolaShellApplication
        : ShellApplication<LolaShellApplication, LolaSettings> {
    private readonly Lazy<IUserProfileHandler> _userHandler;
    private readonly ILogger<LolaShellApplication> _logger;

    public LolaShellApplication(string[] args, IServiceCollection services, Lazy<IUserProfileHandler> userHandler, ILogger<LolaShellApplication> logger)
        : base(args, services) {
        _userHandler = userHandler;
        _logger = logger;
        AddCommand<ProvidersMainMenu>();
        AddCommand<ModelsMainMenu>();
        AddCommand<PersonasMainMenu>();
        AddCommand<JobsMainMenu>();
        if (_userHandler.Value.CurrentUser is not null) AddCommand<UserProfileMainMenu>();
        AddCommand<SettingsCommand>();
        AddCommand<HelpCommand>();
    }

    protected override async Task<Result> OnStart(CancellationToken ct = default) {
        _logger.LogInformation("Starting Lola application...");
        var header = new FigletText($"{Name} {DisplayVersion}").LeftJustified().Color(Color.Fuchsia);
        Output.Write(header);

        var user = _userHandler.Value.CurrentUser;
        return user is not null ? SaluteUser(user) : await RegisterUser(ct);
    }

    protected override Result OnExit() {
        AnsiConsole.MarkupLine("[green]Thank you for using Lola. Goodbye![/]");
        return Result.Success();
    }

    protected override Task<Result> ProcessInteraction(CancellationToken ct = default) {
        _logger.LogInformation("Executing default command...");
        var choice = Input.BuildSelectionPrompt<string>("What would you like to do?")
                          .ConvertWith(MapTo)
                          .AddChoices("Providers",
                                      "Models",
                                      "Personas",
                                      "Tasks",
                                      "UserProfile",
                                      "Settings",
                                      "Help",
                                      "Exit").Show();

        return ProcessCommand(choice, ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }

    protected override Task<Result> ProcessCommand(string[] input, CancellationToken ct) {
        _logger.LogInformation("Processing command: '{Command}'...", string.Join(" ", input));
        return base.ProcessCommand(input, ct);
    }

    protected override bool HandleException<TException>(TException ex) {
        _logger.LogError(ex, "An error occurred while executing the app.");
        return base.HandleException(ex);
    }

    private Result SaluteUser(UserProfileEntity user) {
        Output.WriteLine($"[Green]Hi {user.Name}! Welcome back.[/]");
        Output.WriteLine();
        return Result.Success();
    }

    private Task<Result> RegisterUser(CancellationToken ct = default) {
        Output.WriteLine($"[bold]Welcome to {Name}, your AI assisted shell![/]");
        Output.WriteLine();
        var command = new UpdateUserProfile(this, _userHandler.Value);
        Output.WriteLine("[bold][Yellow]Hi![/] It seems that is the first time that I see you around here.[/]");
        return command.Execute([], ct);
    }
}

---
Program.cs
var app = LolaShellApplication.Create(args, cb => {
    cb.AddAppSettings(); // This will add the values from appsettings.json to the context
    cb.AddUserSecrets<Program>(); // This will add the values from the user secrets to the context
}, ab => {
    ab.ConfigureLogging((loggingBuilder) => {
        var logPath = Path.Combine("logs", "lola-.log");
        Log.Logger = new LoggerConfiguration()
                    .ReadFrom.Configuration(ab.Configuration)
                    .Enrich.FromLogContext()
                    .WriteTo.File(logPath,
                                  fileSizeLimitBytes: 5 * 1024 * 1024,
                                  rollingInterval: RollingInterval.Day,
                                  retainedFileCountLimit: 7) // 5MB file size limit
                    .CreateLogger();

        loggingBuilder.AddSerilog(dispose: true);
    });
    ab.SetOutputHandler(new ConsoleOutput());
    ab.SetInputHandler(new ConsoleInput());
    ab.Services.Configure<LolaSettings>(ab.Configuration.GetSection("Lola"));
    ab.Services.AddOptions<LolaSettings>();

    ab.Services.AddOpenAI();
    ab.Services.AddAnthropic();

    ab.Services.AddScoped<IHttpConnectionHandler, HttpConnectionHandler>();
    ab.Services.AddScoped(p => new Lazy<IHttpConnectionHandler>(p.GetRequiredService<IHttpConnectionHandler>));

    ab.Services.AddSingleton<IUserProfileStorage, UserProfileStorage>();
    ab.Services.AddScoped<IUserProfileDataSource, UserProfileDataSource>();
    ab.Services.AddScoped<IUserProfileHandler, UserProfileHandler>();
    ab.Services.AddScoped(p => new Lazy<IUserProfileDataSource>(p.GetRequiredService<IUserProfileDataSource>));
    ab.Services.AddScoped(p => new Lazy<IUserProfileHandler>(p.GetRequiredService<IUserProfileHandler>));

    ab.Services.AddSingleton<IProviderStorage, ProviderStorage>();
    ab.Services.AddScoped<IProviderDataSource, ProviderDataSource>();
    ab.Services.AddScoped<IProviderHandler, ProviderHandler>();
    ab.Services.AddScoped(p => new Lazy<IProviderDataSource>(p.GetRequiredService<IProviderDataSource>));
    ab.Services.AddScoped(p => new Lazy<IProviderHandler>(p.GetRequiredService<IProviderHandler>));

    ab.Services.AddSingleton<IModelStorage, ModelStorage>();
    ab.Services.AddScoped<IModelDataSource, ModelDataSource>();
    ab.Services.AddScoped<IModelHandler, ModelHandler>();
    ab.Services.AddScoped(p => new Lazy<IModelDataSource>(p.GetRequiredService<IModelDataSource>));
    ab.Services.AddScoped(p => new Lazy<IModelHandler>(p.GetRequiredService<IModelHandler>));

    ab.Services.AddSingleton<IPersonaStorage, PersonaStorage>();
    ab.Services.AddScoped<IPersonaDataSource, PersonaDataSource>();
    ab.Services.AddScoped<IPersonaHandler, PersonaHandler>();
    ab.Services.AddScoped(p => new Lazy<IPersonaDataSource>(p.GetRequiredService<IPersonaDataSource>));
    ab.Services.AddScoped(p => new Lazy<IPersonaHandler>(p.GetRequiredService<IPersonaHandler>));

    ab.Services.AddSingleton<IJobStorage, JobStorage>();
    ab.Services.AddScoped<IJobDataSource, JobDataSource>();
    ab.Services.AddScoped<IJobHandler, JobHandler>();
    ab.Services.AddScoped(p => new Lazy<IJobDataSource>(p.GetRequiredService<IJobDataSource>));
    ab.Services.AddScoped(p => new Lazy<IJobHandler>(p.GetRequiredService<IJobHandler>));
});

try {
    await app.RunAsync();
}
finally {
    Log.CloseAndFlush();
}

---
appsettings.json
{
  "Lola": {
    "DefaultAIProvider": "Anthropic",
    "AvailableModels": [
      "claude-3-5-sonnet-20240620",
      "claude-3-haiku-20240307"
    ]
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ],
    "Properties": {
      "Application": "Lola"
    }
  },
  "HttpClient": {
    "Anthropic": {
      "BaseAddress": "https://api.anthropic.com",
      "Endpoints": {
        "Chat": "/v1/messages"
      },
      "Authentication": {
        "Type": "ApiKey"
      },
      "CustomHeaders": {
        "anthropic-version": [ "2023-06-01" ]
      }
    },
    "OpenAI": {
      "BaseAddress": "https://api.openai.com",
      "Endpoints": {
        "Chat": "/v1/chat/completions"
      },
      "Authentication": {
        "Type": "ApiKey"
      }
    }
  }
}

---
Commands\LolaCommand.cs
using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Commands;

public abstract class LolaCommand<TCommand>(IHasChildren parent, string command, Action<TCommand>? configure = null)
    : Command<TCommand>(parent, command, configure)
    where TCommand : LolaCommand<TCommand> {
    protected string ErrorText { get; set; } = string.Empty;

    protected virtual Result HandleCommand()
        => throw new NotImplementedException();
    protected sealed override Result Execute() {
        try {
            var result = HandleCommand();
            Output.WriteLine();
            return result;
        }
        catch (Exception ex) {
            return HandleException(ex);
        }
    }

    protected virtual Task<Result> HandleCommandAsync(CancellationToken ct = default)
        => Task.Run(HandleCommand, ct);

    protected sealed override async Task<Result> ExecuteAsync(CancellationToken ct = default) {
        try {
            var result = await HandleCommandAsync(ct);
            Output.WriteLine();
            return result;
        }
        catch (ValidationException ex) {
            return HandleValidationErrors(ex);
        }
        catch (Exception ex) {
            return HandleException(ex);
        }
    }

    private Result HandleException(Exception ex) {
        Logger.LogError(ex, "{Command} Error!", typeof(TCommand).Name);
        Output.WriteError(ex, $"An error has occurred while {ErrorText}.");
        Output.WriteLine();
        return Result.Error(ex);
    }

    private Result HandleValidationErrors(ValidationException ex) {
        var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
        Logger.LogError(ex, "{Command} Validation Error!\n{Errors}", typeof(TCommand).Name, errors);
        Output.WriteLine($"[red]We found some problems while {ErrorText}.\nPlease correct the following errors and try again.\n{errors}[/]");
        return Result.Invalid(ex.Errors);
    }
}

---
data\models.json
[
  {
    "Id": 1,
    "ProviderId": 1,
    "Name": "GPT-4o",
    "MaximumContextSize": 128000,
    "MaximumOutputTokens": 4096,
    "InputCostPerMillionTokens": 5,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2023-10-01",
    "Selected": false,
    "Key": "gpt-4o"
  },
  {
    "Id": 2,
    "ProviderId": 2,
    "Name": "Claude 3.5 Sonnet",
    "MaximumContextSize": 200000,
    "MaximumOutputTokens": 8192,
    "InputCostPerMillionTokens": 3,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2024-04-01",
    "Selected": true,
    "Key": "claude-3-5-sonnet-20240620"
  }
]
---
data\personas.json
[
  {
    "Expertise": "AI capabilities, roles, and effective prompt engineering",
    "Goals": [
      "create detailed, accurate, and tailored descriptions for various AI agents"
    ],
    "Requirements": [
      "always prioritize clarity and specificity in your agent descriptions.",
      "include both capabilities and limitations in every agent description.",
      "ensure that the descriptions you create are ethically sound and promote responsible AI use."
    ],
    "Internal": true,
    "Id": 1,
    "Name": "Agent Creator",
    "Restrictions": [
      "create descriptions for AI agents that could be used for harmful or illegal purposes",
      "misrepresent an AI agent\u0027s capabilities or limitations",
      "use ambiguous or vague language in your descriptions"
    ],
    "Traits": [
      "You have extensive knowledge of various AI models and their capabilities.",
      "You understand the importance of ethical AI behavior and incorporate this into your descriptions.",
      "You are familiar with different domains and can tailor agent descriptions to specific fields."
    ],
    "Questions": [],
    "Role": "AI Agent Description Specialist",
    "Characteristics": [
      "You carefully break down requirements and information to create comprehensive agent descriptions.",
      "You can create descriptions for a wide range of AI agent types and purposes.",
      "You ensure all aspects of an agent\u0027s role and capabilities are highly detailed and clearly defined.",
      "You can come up with unique and effective ways to describe AI agents\u0027 functions and limitations.",
      "You prioritize clear, concise, and unambiguous language in your descriptions.",
      "You are able to adapt your descriptions to different contexts and requirements."
    ]
  }
]
---
data\providers.json
[
  {
    "Name": "OpenAI",
    "Id": 1
  },
  {
    "Name": "Anthropic",
    "Id": 2
  }
]
---
data\tasks.json
[
  {
    "Assumptions": [
      "The user has already provided a Name, Role, and list of Goals for the AI agent",
      "The user may not be an expert in AI or agent design, so questions should be clear and avoid overly technical jargon",
      "The questions generated will be used in a subsequent step to create a full agent description",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "make assumptions about the agent's capabilities beyond what is explicitly stated in the provided information",
      "generate questions about technical implementation details that the average user wouldn't be able to answer",
      "include questions that have already been answered by the provided Name, Role, and Goals",
      "include questions that were already answered by the user in a previous interaction"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalized advice on reducing carbon footprint\n2. Educate users on environmental issues\n3. Suggest eco-friendly alternatives for daily activities\n\nResponse:\n{\"Questions\":[{\"Question\":\"What level of expertise should EcoAdvise have? (e.g., general knowledge, academic-level, or industry-expert level)\",\"Explanation\":\"This will help determine the depth and complexity of advice the agent can provide.\"}]}",
      "Input:\nName: CodeCraft\nRole: Programming Assistant\nGoals:\n1. Help users debug their code\n2. Explain programming concepts\n3. Suggest optimizations for code efficiency\nPrevious Questions:\nQ: What programming languages should CodeCraft be proficient in?\nThis will define the scope of the agent's expertise and ensure it can assist with relevant languages.\nA: C# .NET\n\nResponse:\n{\"Questions\":[{\"Question\":\"Should CodeCraft be able to generate code snippets or complete functions, or only provide guidance?\",\"Explanation\":\"This will clarify the extent of the agent's coding capabilities and set appropriate user expectations.\"}]}"
    ],
    "Guidelines": [
      "Begin by carefully analyzing the provided Name, Role, and Goals to understand the general direction of the agent.",
      "Generate questions that cover different aspects of the agent, such as:\n- Specific capabilities within the given role;\n- Intended user interaction style;\n- Ethical guidelines and limitations;\n- Knowledge base and areas of expertise; and\n- Personality traits or communication style;",
      "Ensure questions are open-ended to encourage detailed responses.",
      "Frame questions in a way that helps users think deeply about their agent's design.",
      "Include a mix of questions about both capabilities and limitations."
    ],
    "Goals": [
      "generate insightful and relevant questions that will help users further define the characteristics, capabilities, and limitations of the AI agent they want to create",
      "analyze the provided Name, Role, and Goals of the prospective AI agent",
      "identify areas where more information is needed to create a comprehensive agent description",
      "generate clear, specific questions that will elicit useful information from the user",
      "ensure that the questions cover a wide range of agent characteristics, including capabilities, limitations, ethical considerations, and interaction style",
      "adapt the questions based on the context provided by the initial input"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nPrevious Questions:\n<<Questions>>\n",
    "Internal": true,
    "Id": 1,
    "Name": "Ask Questions about the AI Agent",
    "Scope": [
      "generating questions based solely on the Name, Role, and Goals provided by the user",
      "focusing on aspects of the agent that are not fully clear from the initial information",
      "covering various aspects of agent design, including but not limited to: knowledge base, interaction style, ethical guidelines, specific capabilities, and limitations"
    ],
    "Requirements": [
      "generate ONE question per request",
      "generate questions directly relevant to the provided Name, Role, and Goals",
      "generate questions designed to elicit specific, actionable information for agent creation",
      "generate an output that is a valid JSON file following strictly the schema defined in the prompt"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Questions\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"Question\":{\"type\":\"string\"},\"Explanation\":{\"type\":\"string\"}},\"required\":[\"Explanation\",\"Question\"]}}}}",
    "ResponseType": "Json",
    "Validations": [
      "Ensuring each question is directly relevant to the provided Name, Role, and Goals",
      "Checking that the set of questions covers a diverse range of agent characteristics",
      "Verifying that each question is clear, concise, and likely to elicit useful information",
      "Confirming that the questions do not make unwarranted assumptions about the agent",
      "Reviewing the brief explanations to ensure they clearly convey why each question is important"
    ]
  },
  {
    "Assumptions": [
      "The user has provided a Name, Role, and list of Goals for the AI agent",
      "The user has answered additional questions about the AI agent",
      "All provided information is relevant to the Persona creation",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "introduce new information that isn't derived from the user's input or question responses",
      "generate properties that contradict the provided Name, Role, Goals or Answered Questions",
      "include traits in multiple categories (e.g., a trait shouldn't appear in both Traits and Important lists)"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalised advice at reducing carbon footprint\n2. Educate the users on environmental issues\n3. Suggest eco-friendly alternative for daiyl activities\nQuestions:\nQ: What level of expertise should EcoAdvise have?\nThis question will help identify the scope and depth of the knowledge that the agent have.\nA: EcoAdvise should have industry-expert level knowledge.\nQ: How should EcoAdvise balance between providing scientific facts and motivating users?\nThis question will help define the type of answer the user is expecting.\nA: EcoAdvise should use a 70-30 split, with 70% focus on scientific facts and 30% on motivation.\n\nOutput:\n{\"Role\":\"Environmental Sustainability Consultant\",\"Goals\":[\"Provide personalized advice on reducing carbon footprint\",\"Educate the user on environmental issues\",\"Suggest eco-friendly alternatives for daily activities\"],\"Expertise\":\"Advanced environmental science with a focus on sustainability and carbon footprint reduction\",\"Traits\":[\"Broadly Knowlegeable: Knowledgeable about global and local environmental issues\",\"Excellent Communicator: Able to communicate complex scientific concepts clearly\",\"Data-Driven: Data-driven in approach to sustainability\"],\"Important\":[\"You MUST provide accurate, up-to-date environmental information\",\"ALWAYS respects user privacy when handling location data\",\"You MUST balances scientific facts with motivational encouragement\"],\"Negative\":[\"be alarmist or overly pessimistic about environmental issues\",\"recommend unsustainable or unethical practices\",\"ignore local context in sustainability advice\"],\"Other\":[\"Uses a 70-30 split between scientific facts and motivation in communications\",\"Capable of tailoring advice to specific geographic locations\",\"Stays updated on the latest environmental research and sustainability practices\"]}\n"
    ],
    "Guidelines": [
      "Begin by carefully analyzing all provided information: Name, Role, Goals, and question responses",
      "For Expertise, identify the core area of knowledge or skill central to the Persona's role and goals",
      "For Traits, identify characteristics that support the Persona's role and goals but aren't crucial",
      "For Important, identify crucial characteristics without which the Persona couldn't fulfill its role or achieve its goals",
      "For Negative, identify traits or behaviors that would hinder the Persona's effectiveness or contradict its purpose",
      "For Other, include any relevant information that doesn't fit into the above categories but adds depth to the Persona",
      "Ensure all generated properties align with the Persona's Name, Role, and Goals",
      "Provide clear, concise explanations for each generated property"
    ],
    "Goals": [
      "generate the Expertise, Traits, Important, Negative, and Other properties of the Persona",
      "ensure that the generated properties are consistent with the initial input and question responses",
      "create a comprehensive and coherent Persona description",
      "provide explanations for each generated property to justify its relevance to the Persona"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nQuestions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 2,
    "Name": "Generate AI Agent Persona",
    "Scope": [
      "generating the Expertise, Traits, Important, Negative, and Other properties based solely on the provided information",
      "ensuring all generated properties align with the Persona's Name, Role, and Goals",
      "focusing on creating a well-rounded and consistent Persona description"
    ],
    "Requirements": [
      "generate all five properties: Expertise, Traits, Important, Negative, and Other",
      "rewrite the Role and Goals properties with correct English without changing their intended contents",
      "ensure the Role property is a text that is a continuation of: 'You are a highly capable and versatile {Role}'",
      "ensure that each Goal is a simple phrase that is a continuation of: 'Your goal is {Goal}'",
      "ensure the Expertise property is a text describing list of skills the agent and is a continuation of 'You are an expert in {Expertise}'",
      "ensure the Traits, Important, Negative, and Other properties are lists of strings",
      "ensure that each Trait also include a short explanation of their intent. For example:\n Highly Analytical: You meticulously break down complex programming problems and user requirements to provide comprehensive solutions and explanations.\n Excellent Communicator: You explain complex technical concepts and code structures in clear, accessible language tailored to the USER's level of understanding.",
      "ensure that the Important and Negative lists do not contradict each other",
      "ensure that each Important item is written in an imperative way as continuation of the text: '**IMPORTANT, ** {Important_Item}'. They should normally start with 'You MUST ' or 'ALWAYS '.",
      "ensure that each Negative item is written as their POSITIVE version as a continuation of the text: '**NEVER, IN ANY CIRCUMSTANCE, ** {Negative_Item}'",
      "provide a brief explanation for each generated property, justifying its relevance to the Persona"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Role\":{\"type\":\"string\"},\"Goals\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Expertise\":{\"type\":\"string\"},\"Traits\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Important\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Negative\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Other\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"Role\",\"Goals\",\"Expertise\",\"Traits\",\"Important\",\"Negative\",\"Other\"]}",
    "ResponseType": "Json",
    "Validations": [
      "ensuring each generated property is directly relevant to and consistent with the provided information",
      "checking that the Expertise aligns closely with the Role and Goals",
      "verifying that Traits and Important lists contain distinct items that don't contradict each other",
      "confirming that Negative traits are genuinely detrimental to the Persona's purpose",
      "reviewing the Other list to ensure it adds value without redundancy",
      "validating that clear, concise explanations are provided for each generated property"
    ]
  }
]

---
data\users.json
[
  {
    "Internal": true,
    "Name": "User",
    "Language": "English",
    "Facts": [],
    "Id": 0
  },
  {
    "Internal": false,
    "Name": "Argus",
    "Language": "English",
    "Facts": [],
    "Id": 1
  }
]
---
Jobs\Commands\AddJob.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Jobs.Commands;

public class AddJob(IHasChildren parent, IJobHandler jobHandler)
    : LolaCommand<AddJob>(parent, "Generate", n => {
        n.Aliases = ["gen"];
        n.Description = "Generate a new job";
        n.ErrorText = "generating the new job";
        n.Help = "Generate a new agent job using AI assistance.";
    }) {
    private const int _maxQuestions = 10;

    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Jobs->Generate command...");
        var job = new JobEntity();
        await SetUpAsync(job, ct);
        await AskAdditionalQuestions(job, ct);
        await jobHandler.UpdateCreatedJob(job);

        Output.WriteLine($"[green]Agent job '{job.Name}' generated successfully.[/]");
        Logger.LogInformation("Job '{JobId}:{JobName}' generated successfully.", job.Id, job.Name);

        ShowResult(job);

        var saveJob = await Input.ConfirmAsync("Are you ok with the generated Agent above?", ct);
        if (saveJob) {
            jobHandler.Add(job);
            Logger.LogInformation("Job '{JobId}:{JobName}' added successfully.", job.Id, job.Name);
            return Result.Success();
        }

        Output.WriteLine("[yellow]Please review the provided answers and try again.[/]");
        return Result.Success();
    }

    private void ShowResult(JobEntity job) {
        Output.WriteLine();
        Output.WriteLine($"[teal]Name:[/] {job.Name}");
        Output.WriteLine("[teal]Goals:[/]");
        Output.WriteLine(string.Join("\n", job.Goals.Select(i => $" - {i}")));
        Output.WriteLine();
    }

    private async Task AskAdditionalQuestions(JobEntity job, CancellationToken ct) {
        for (var questionCount = 0; questionCount < _maxQuestions; questionCount++) {
            Output.WriteLine("[yellow]Let me see if I have more questions...[/]");
            Output.WriteLine("[grey](You can skip the questions by typing 'proceed' at any time.)[/]");

            var queries = await jobHandler.GenerateQuestion(job);
            if (queries.Length == 0) {
                Output.WriteLine("[green]I've gathered sufficient information to generate the agent's job.[/]");
                break;
            }
            var proceed = false;
            foreach (var query in queries) {
                query.Answer = await Input.BuildMultilinePrompt($"Question {questionCount + 1}: {query.Question}")
                                          .ShowAsync(ct);
                if (query.Answer.Equals("proceed", StringComparison.OrdinalIgnoreCase)) {
                    proceed = true;
                    break;
                }
                job.Questions.Add(query);
            }

            if (!proceed) continue;
            Output.WriteLine("[green]Ok. Let's proceed with the Agent's Task generation.[/]");
            break;
        }
    }

    private async Task SetUpAsync(JobEntity job, CancellationToken ct) {
        job.Name = await Input.BuildTextPrompt<string>("How would you like to call the Agent?")
                                  .AddValidation(name => JobEntity.ValidateName(null, name, jobHandler))
                                  .ShowAsync(ct);
        var goal = await Input.BuildMultilinePrompt($"What is the Main Goal for the [white]{job.Name}[/]?")
                              .AddValidation(JobEntity.ValidateGoal)
                              .ShowAsync(ct);
        job.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
        var addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        while (addAnotherGoal) {
            goal = await Input.BuildMultilinePrompt("Additional goal: ")
                              .AddValidation(JobEntity.ValidateGoal)
                              .ShowAsync(ct);
            job.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
            addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        }
    }
}

---
Jobs\Commands\JobsMainMenu.cs
namespace Lola.Jobs.Commands;

public class JobsMainMenu(IHasChildren parent)
    : LolaCommand<JobsMainMenu>(parent, "Jobs", n => {
        n.Description = "Manage Jobs";
        n.ErrorText = "displaying the job's main menu";
        n.AddCommand<ListJobs>();
        //n.AddCommand<TaskCreateCommand>();
        //n.AddCommand<TaskUpdateCommand>();
        //n.AddCommand<TaskRemoveCommand>();
        //AddCommand<TaskViewCommand>();
        n.AddCommand<HelpCommand>();
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Jobs command...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(ct);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }
}

---
Jobs\Commands\ListJobs.cs
namespace Lola.Jobs.Commands;

public class ListJobs(IHasChildren parent, IJobHandler jobHandler)
    : LolaCommand<ListJobs>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.ErrorText = "listing the jobs";
        n.Description = "List the existing jobs.";
    }) {
    protected override Result HandleCommand() {
        Logger.LogInformation("Executing Jobs->List command...");
        var jobs = jobHandler.List();
        if (jobs.Length == 0) {
            Output.WriteLine("[yellow]No jobs found.[/]");
            return Result.Success();
        }

        var sortedJobs = jobs.OrderBy(m => m.Name);
        ShowList(sortedJobs);

        return Result.Success();
    }

    private void ShowList(IOrderedEnumerable<JobEntity> sortedJobs) {
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Main Goal[/]"));
        foreach (var job in sortedJobs)
            table.AddRow(job.Name, job.Goals.FirstOrDefault() ?? "[red][Undefined][/]");
        Output.Write(table);
    }
}

---
Jobs\Commands\RemoveJob.cs
namespace Lola.Jobs.Commands;

public class RemoveJob(IHasChildren parent, IJobHandler handler)
    : LolaCommand<RemoveJob>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove a job";
        n.ErrorText = "removing the job";
        n.Help = "Remove an existing agent's job.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Jobs->Remove command...");
        var jobs = handler.List();
        if (jobs.Length == 0) {
            Output.WriteLine("[yellow]No jobs found.[/]");
            Logger.LogInformation("No jobs found. Remove job action cancelled.");
            return Result.Success();
        }
        var job = await this.SelectEntityAsync<JobEntity, uint>(jobs.OrderBy(p => p.Name), p => p.Name, ct);
        if (job is null) {
            Logger.LogInformation("No job selected.");
            return Result.Success();
        }

        if (!await Input.ConfirmAsync($"Are you sure you want to remove the job '{job.Name}' ({job.Id})?", ct)) {
            Logger.LogInformation("Job removal cancelled by user.");
            return Result.Invalid("Action cancelled.");
        }

        handler.Remove(job.Id);
        Output.WriteLine($"[green]Job '{job.Name}' removed successfully.[/]");
        Logger.LogInformation("Job '{JobId}:{JobName}' removed successfully.", job.Id, job.Name);
        return Result.Success();
    }
}

---
Jobs\Commands\UpdateJob.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Jobs.Commands;

public class UpdateJob(IHasChildren parent, IJobHandler handler)
    : LolaCommand<UpdateJob>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update a job";
        n.ErrorText = "updating the job";
        n.Help = "Update an existing agent's job.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Jobs->Update command...");
        var jobs = handler.List();
        if (jobs.Length == 0) {
            Output.WriteLine("[yellow]No jobs found.[/]");
            Logger.LogInformation("No jobs found. Update job action cancelled.");
            return Result.Success();
        }
        var job = await this.SelectEntityAsync<JobEntity, uint>(jobs.OrderBy(p => p.Name), p => p.Name, ct);
        if (job is null) {
            Logger.LogInformation("No job selected.");
            return Result.Success();
        }

        await SetUpAsync(job, ct);

        handler.Update(job);
        Output.WriteLine($"[green]Job '{job.Name}' updated successfully.[/]");
        Logger.LogInformation("Job '{JobId}:{JobName}' updated successfully.", job.Id, job.Name);
        return Result.Success();
    }

    private async Task SetUpAsync(JobEntity job, CancellationToken ct) {
        // Update Name
        job.Name = await Input.BuildTextPrompt<string>("- Name (ENTER to keep current):")
                                  .WithDefault(job.Name)
                                  .ShowOptionalFlag()
                                  .AddValidation(name => JobEntity.ValidateName(job.Id, name, handler))
                                  .ShowAsync(ct);

        // Update Goals
        Output.WriteLine($"This job has currently {job.Goals.Count} goals.");
        var goalCount = 0;
        while (goalCount < job.Goals.Count) {
            job.Goals[goalCount] = await Input.BuildMultilinePrompt($"- Goal {goalCount + 1}:")
                                                  .WithDefault(job.Goals[goalCount])
                                                  .AddValidation(JobEntity.ValidateGoal)
                                                  .ShowAsync(ct);
            goalCount++;
        }
        var addGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        while (addGoal) {
            job.Goals[goalCount] = await Input.BuildMultilinePrompt($"- Goal {goalCount + 1}:")
                                                  .AddValidation(JobEntity.ValidateGoal)
                                                  .ShowAsync(ct);
            addGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        }
    }
}

---
Jobs\Commands\ViewJob.cs
namespace Lola.Jobs.Commands;

public class ViewJob(IHasChildren parent, IJobHandler handler)
    : LolaCommand<ViewJob>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View job details";
        n.ErrorText = "displaying the job information";
        n.Help = "Display detailed information about an agent's job.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Jobs->Info command...");
        var jobs = handler.List();
        if (jobs.Length == 0) {
            Output.WriteLine("[yellow]No jobs found.[/]");
            Logger.LogInformation("No jobs found. View job action cancelled.");
            return Result.Success();
        }
        var job = await this.SelectEntityAsync<JobEntity, uint>(jobs.OrderBy(p => p.Name), p => p.Name, ct);
        if (job is null) {
            Logger.LogInformation("No job selected.");
            return Result.Success();
        }

        ShowDetails(job);
        return Result.Success();
    }

    private void ShowDetails(JobEntity job) {
        Output.WriteLine($"{job.Name} [yellow]Information:[/]");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(JobEntity.Goals)}:[/]");
        foreach (var goal in job.Goals) Output.WriteLine($" - {goal}");
        Output.WriteLine();
    }
}

---
Jobs\Handlers\IJobHandler.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Jobs.Handlers;

public interface IJobHandler {
    JobEntity[] List();
    JobEntity? GetById(uint id);
    JobEntity? Find(Expression<Func<JobEntity, bool>> predicate);
    JobEntity Create(Action<JobEntity> setUp);
    void Add(JobEntity job);
    void Update(JobEntity job);
    void Remove(uint id);

    Task<Query[]> GenerateQuestion(JobEntity job);
    Task UpdateCreatedJob(JobEntity job);
}

---
Jobs\Handlers\JobHandler.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Jobs.Handlers;

public class JobHandler(IServiceProvider services, ILogger<JobHandler> logger)
    : IJobHandler {
    private readonly IModelHandler _modelHandler = services.GetRequiredService<IModelHandler>();
    private readonly IUserProfileHandler _userHandler = services.GetRequiredService<IUserProfileHandler>();
    private readonly IJobDataSource _dataSource = services.GetRequiredService<IJobDataSource>();
    private readonly IPersonaHandler _personaHandler = services.GetRequiredService<IPersonaHandler>();
    private readonly IAgentAccessor _connectionAccessor = services.GetRequiredService<IAgentAccessor>();

    public JobEntity[] List() => _dataSource.GetAll();

    public JobEntity? GetById(uint id) => _dataSource.FindByKey(id);
    public JobEntity? Find(Expression<Func<JobEntity, bool>> predicate) => _dataSource.Find(predicate);

    public JobEntity Create(Action<JobEntity> setUp)
        => _dataSource.Create(setUp);

    public void Add(JobEntity job) {
        if (_dataSource.FindByKey(job.Id) != null)
            throw new InvalidOperationException($"A job with the id '{job.Id}' already exists.");

        var context = Map.FromMap([new(nameof(JobHandler), this)]);
        _dataSource.Add(job, context);
        logger.LogInformation("Added new job: {TaskId} => {TaskName}", job.Name, job.Id);
    }

    public void Update(JobEntity job) {
        if (_dataSource.FindByKey(job.Id) == null)
            throw new InvalidOperationException($"Job with id '{job.Id}' not found.");

        var context = Map.FromMap([new(nameof(JobHandler), this)]);
        _dataSource.Update(job, context);
        logger.LogInformation("Updated job: {TaskId} => {TaskName}", job.Name, job.Id);
    }

    public void Remove(uint id) {
        var task = _dataSource.FindByKey(id)
                     ?? throw new InvalidOperationException($"Job with id '{id}' not found.");

        _dataSource.Remove(id);
        logger.LogInformation("Removed task: {TaskId} => {TaskName}", task.Name, task.Id);
    }

    public async Task<Query[]> GenerateQuestion(JobEntity job) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = _personaHandler.GetById(1) ?? throw new InvalidOperationException("Required persona not found. Name: 'Task Creator'.");
            var jobEntity = GetById(1) ?? throw new InvalidOperationException("Required job not found. Name: 'Ask Questions about the AI Task'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = jobEntity,
                Input = job,
            };
            var task = new Job(context);
            task.Converters.Add(typeof(List<Query>),
                                v => {
                                    var list = (List<Query>)v;
                                    if (list.Count == 0) return string.Empty;
                                    var sb = new StringBuilder();
                                    foreach (var item in list) {
                                        sb.AppendLine($"Q: {item.Question}");
                                        sb.AppendLine($"{item.Explanation}");
                                        sb.AppendLine($"A: {item.Answer}");
                                    }
                                    return sb.ToString();
                                });
            var result = await task.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            var response = context.OutputAsMap.GetList<Map>("Questions");
            return response.ToArray(i => new Query {
                Question = i.GetRequiredValueAs<string>(nameof(Query.Question)),
                Explanation = i.GetRequiredValueAs<string>(nameof(Query.Explanation)),
            });
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for job {JobName}", job.Name);
            throw;
        }
    }

    public async Task UpdateCreatedJob(JobEntity job) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = _personaHandler.GetById(1) ?? throw new InvalidOperationException("Required job not found. Name: 'Agent Creator'.");
            var jobEntity = GetById(2) ?? throw new InvalidOperationException("Required task not found. Name: 'Ask Questions about the AI Agent'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = jobEntity,
                Input = job,
            };
            var task = new Job(context);
            task.Converters.Add(typeof(List<Query>),
                                v => {
                                    var list = (List<Query>)v;
                                    if (list.Count == 0) return string.Empty;
                                    var sb = new StringBuilder();
                                    foreach (var item in list) {
                                        sb.AppendLine($"Q: {item.Question}");
                                        sb.AppendLine($"{item.Explanation}");
                                        sb.AppendLine($"A: {item.Answer}");
                                    }
                                    return sb.ToString();
                                });
            var result = await task.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            job.Goals = context.OutputAsMap.GetRequiredList<string>(nameof(JobEntity.Goals));
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for job {JobName}", job.Name);
            throw;
        }
    }
}

---
Jobs\Repositories\IJobDataSource.cs
namespace Lola.Jobs.Repositories;

public interface IJobDataSource
    : IDataSource<JobEntity, uint>;

---
Jobs\Repositories\IJobStorage.cs
namespace Lola.Jobs.Repositories;

public interface IJobStorage
    : IStorage<JobEntity, uint>;

---
Jobs\Repositories\JobDataSource.cs
namespace Lola.Jobs.Repositories;

public class JobDataSource(IJobStorage storage)
    : DataSource<IJobStorage, JobEntity, uint>(storage),
      IJobDataSource;

---
Jobs\Repositories\JobEntity.cs
using Task = DotNetToolbox.AI.Jobs.Task;

namespace Lola.Jobs.Repositories;

public class JobEntity
    : Entity<JobEntity, uint> {
    public string Name { get; set; } = string.Empty;
    public List<string> Goals { get; set; } = [];

    public List<Query> Questions { get; init; } = [];

    public List<string> Scope { get; init; } = [];
    public List<string> Requirements { get; init; } = [];
    public List<string> Assumptions { get; init; } = [];
    public List<string> Constraints { get; init; } = [];
    public List<string> Examples { get; init; } = [];
    public List<string> Guidelines { get; init; } = [];
    public List<string> Validations { get; init; } = [];

    public string InputTemplate { get; init; } = string.Empty;
    public TaskResponseType ResponseType { get; init; }
    public string ResponseSchema { get; init; } = string.Empty;

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        var action = IsNotNull(context).GetRequiredValueAs<EntityAction>(nameof(EntityAction));
        result += ValidateName(action == EntityAction.Insert ? null : Id, Name, context.GetRequiredValueAs<IJobHandler>(nameof(JobHandler)));
        result += ValidateGoals(Goals);
        return result;
    }

    public static Result ValidateName(uint? id, string? name, IJobHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && (id == null || p.Id != id)) is not null)
            result += new ValidationError("A job with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateGoal(string? goal) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(goal))
            result += new ValidationError("The goal cannot be null or empty.", nameof(Goals));
        return result;
    }

    public static Result ValidateGoals(List<string> goals) {
        var result = Result.Success();
        if (goals.Count == 0)
            result += new ValidationError("At least one goal is required.", nameof(Goals));
        return goals.Aggregate(result, (current, goal) => current + ValidateGoal(goal));
    }

    public static implicit operator Task(JobEntity entity)
        => new(entity.Id) {
            Name = entity.Name,
            Goals = entity.Goals,
            Scope = entity.Scope,
            Requirements = entity.Requirements,
            Assumptions = entity.Assumptions,
            Constraints = entity.Constraints,
            Examples = entity.Examples,
            Guidelines = entity.Guidelines,
            Validations = entity.Validations,
            InputTemplate = entity.InputTemplate,
            ResponseType = entity.ResponseType,
            ResponseSchema = entity.ResponseSchema,
        };
}

---
Jobs\Repositories\JobStorage.cs
namespace Lola.Jobs.Repositories;

public class JobStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<JobEntity, uint>("tasks", configuration),
      IJobStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}

---
Main\Commands\HelpCommand.cs
namespace Lola.Main.Commands;

public class HelpCommand(IHasChildren parent)
    : LolaCommand<HelpCommand>(parent, "Help", n => {
        n.Aliases = ["?"];
        n.Description = "Show help";
        n.ErrorText = "displaying the help information";
        n.Help = "Display this help information.";
        n.AddParameter("Target", string.Empty);
    }) {
    private const int _indentSize = 4;

    protected override Result HandleCommand() {
        Logger.LogInformation("Executing Help command...");
        ShowHelp();
        return Result.Success();
    }

    private void ShowHelp() {
        var target = Context.GetValueAs<string>("Target");
        var command = Parent.Commands.FirstOrDefault(i => i.Name.Equals(target, StringComparison.OrdinalIgnoreCase));
        var node = command ?? Parent;
        var helpText = GetHelp(node);
        Output.Write(helpText);
    }

    private static string GetHelp(IHasChildren node) {
        var builder = new StringBuilder();
        AppendNodeDescription(builder, node);
        AppendUsage(builder, node);
        AppendAliases(builder, node);
        AppendItems(builder, "Options", node.Options);
        AppendItems(builder, "Parameters", node.Parameters);
        AppendItems(builder, "Commands", node.Commands);
        return builder.ToString();
    }

    private static void AppendNodeDescription(StringBuilder builder, INode node) {
        if (node is IApplication app) builder.AppendLine(app.FullName);
        if (string.IsNullOrWhiteSpace(node.Help)) return;
        builder.AppendLine(node.Help.Trim());
    }

    private static void AppendUsage(StringBuilder builder, IHasChildren node) {
        if (builder.Length != 0) builder.AppendLine();
        builder.AppendLine("Usage:");
        AppendDefaultUsage(builder, node);
        AppendUsageWithParameters(builder, node);
    }

    private static void AppendDefaultUsage(StringBuilder builder, IHasChildren node) {
        if (node.Commands.Length == 0 && node.Parameters.Length != 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [[Options]]");
        if (node.Commands.Length != 0) builder.Append(" [[Commands]]");
        builder.AppendLine();
    }

    private static void AppendUsageWithParameters(StringBuilder builder, IHasChildren node) {
        if (node.Parameters.Length == 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [[Options]]");
        foreach (var parameter in node.Parameters) {
            if (parameter.IsRequired) builder.Append($" <{parameter.Name}>");
            else builder.Append($" [<{parameter.Name}>]");
        }
        builder.AppendLine();
    }

    private static void AppendAliases(StringBuilder builder, IHasChildren node) {
        if (node.Aliases.Length == 0) return;
        builder.AppendLine();
        builder.Append("Aliases: ").AppendJoin(", ", node.Aliases).AppendLine();
    }

    private static void AppendItems(StringBuilder builder, string section, IReadOnlyCollection<INode> items) {
        if (items.Count == 0) return;
        builder.AppendLine();
        builder.AppendLine($"{section}:");
        foreach (var item in items)
            AppendItem(builder, item);
    }

    private static void AppendItem(StringBuilder builder, INode node) {
        builder.Append(' ', _indentSize);
        var ids = GetIds(node);
        builder.Append(ids);
        AppendNodeDescription(builder, node, ids.Length + _indentSize);
    }

    private static string GetIds(INode node) {
        string[] ids = node is IArgument _
                           ? [$"-{node.Name.ToLowerInvariant()}", .. node.Aliases.Select(a => $"-{a}")]
                           : [node.Name, .. node.Aliases];
        return string.Join(", ", ids);
    }

    private static void AppendNodeDescription(StringBuilder builder, INode node, int length) {
        var lines = node.Help.Split(System.Environment.NewLine, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length == 0) {
            builder.AppendLine();
            return;
        }
        builder.Append(' ', 30 - length).AppendLine(lines[0]);
        foreach (var line in lines.Skip(1)) builder.Append(' ', 30).AppendLine(line);
    }
}

---
Main\Commands\SettingsCommand.cs
namespace Lola.Main.Commands;

public class SettingsCommand(IHasChildren parent, IOptions<LolaSettings> settings)
    : LolaCommand<SettingsCommand>(parent, "Settings", n => {
        n.Aliases = ["set"];
        n.Description = "Show settings";
        n.ErrorText = "displaying the settings";
        n.Help = "Display the current configuration of Lola.";
    }) {
    private readonly LolaSettings _settings = settings.Value;

    protected override Result HandleCommand() {
        Logger.LogInformation("Executing Settings command...");
        DrawTable();
        return Result.Success();
    }

    private void DrawTable() {
        var table = new Table();
        table.AddColumn("Setting");
        table.AddColumn("Value");
        table.AddRow("Default AI Provider", _settings.DefaultAIProvider);
        table.AddRow("Available Models", string.Join(", ", _settings.AvailableModels));
        Output.Write(table);
        Output.WriteLine();
    }
}

---
Models\Commands\AddModel.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Models.Commands;

public class AddModel(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : LolaCommand<AddModel>(parent, "Add", c => {
        c.Aliases = ["new"];
        c.Description = "Add a new model";
        c.ErrorText = "adding the new model";
        c.Help = "Register a new model from a specific LLM provider.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->Add command...");
        var providers = providerHandler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow bold]No providers available. Please add a provider first.[/]");
            Logger.LogInformation("No providers available. Create model action cancelled.");
            return Result.Invalid("No providers available.");
        }

        var provider = await Input.BuildSelectionPrompt<ProviderEntity>("Select a provider:")
                                  .ConvertWith(p => $"{p.Id}: {p.Name}")
                                  .AddChoices(providers)
                                  .ShowAsync(ct);
        var model = new ModelEntity();
        await SetUpAsync(model, provider, ct);

        modelHandler.Add(model);
        Output.WriteLine($"[green]Settings '{model.Name}' added successfully.[/]");
        Logger.LogInformation("Settings '{ModelKey}:{ModelName}' added successfully.", model.Key, model.Name);
        return Result.Success();
    }

    private async Task SetUpAsync(ModelEntity model, ProviderEntity provider, CancellationToken ct) {
        model.Key = await Input.BuildTextPrompt<string>("Enter the model identifier:")
                               .AddValidation(key => ModelEntity.ValidateKey(null, key, modelHandler))
                               .ShowAsync(ct);
        model.Name = await Input.BuildTextPrompt<string>("Enter the model name:")
                                .AddValidation(name => ModelEntity.ValidateName(null, name, modelHandler))
                                .ShowAsync(ct);
        model.ProviderId = provider.Id;
        model.MaximumContextSize = await Input.BuildTextPrompt<uint>("Enter the maximum context size:")
                                              .ShowAsync(ct);
        model.MaximumOutputTokens = await Input.BuildTextPrompt<uint>("Enter the maximum output tokens:")
                                               .ShowAsync(ct);
        model.InputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the input cost per million tokens:")
                                                     .AddValidation(ModelEntity.ValidateInputCost)
                                                     .ShowAsync(ct);
        model.OutputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the output cost per million tokens:")
                                                      .AddValidation(ModelEntity.ValidateOutputCost)
                                                      .ShowAsync(ct);
        model.TrainingDateCutOff = await Input.BuildTextPrompt<DateOnly?>("Enter the training data cut-off date (YYYY-MM-DD):")
                                              .AddValidation(ModelEntity.ValidateDateCutOff)
                                              .ShowAsync(ct);
    }
}

---
Models\Commands\ListModels.cs
namespace Lola.Models.Commands;

public class ListModels(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : LolaCommand<ListModels>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List models";
        n.ErrorText = "listing the existing models";
        n.Help = "List all the models or those from a specific LLM provider.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->List command...");
        var providers = providerHandler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow bold]No providers available. Please add a provider first.[/]");
            Logger.LogInformation("No providers available. List models action cancelled.");
            return Result.Invalid("No providers available.");
        }
        var choices = providers.ToList(p => new ListItem<ProviderEntity, uint>(p.Id, p.Name, p));
        var cancelOption = new ListItem<ProviderEntity, uint>(0, "All", null);
        choices.Insert(0, cancelOption);
        var selectedChoice = await Input.BuildSelectionPrompt<ListItem<ProviderEntity, uint>>("Select a provider:")
                                    .ConvertWith(p => p.Text)
                                    .AddChoices([.. choices])
                                    .ShowAsync(ct);
        var models = selectedChoice.Key == default
            ? modelHandler.List()
            : modelHandler.List(selectedChoice.Item!.Id);
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            return Result.Success();
        }

        var sortedList = models.OrderBy(m => m.Provider!.Name).ThenBy(m => m.Name);

        ShowList(sortedList);

        return Result.Success();
    }

    private void ShowList(IOrderedEnumerable<ModelEntity> sortedModels) {
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Provider[/]"));
        table.AddColumn(new("[yellow]Id[/]"));
        table.AddColumn(new TableColumn("[yellow]Map Size[/]").RightAligned());
        table.AddColumn(new TableColumn("[yellow]Output Tokens[/]").RightAligned());
        foreach (var model in sortedModels) {
            var provider = providerHandler.GetById(model.ProviderId)!;
            table.AddRow(
                model.Name,
                provider.Name,
                model.Key,
                $"{model.MaximumContextSize:#,##0}",
                $"{model.MaximumOutputTokens:#,##0}"
            );
        }
        Output.Write(table);
    }
}

---
Models\Commands\ModelsMainMenu.cs
namespace Lola.Models.Commands;

public class ModelsMainMenu(IHasChildren parent)
    : LolaCommand<ModelsMainMenu>(parent, "Models", n => {
        n.Description = "Manage AI Models";
        n.ErrorText = "displaying model's main menu";
        n.Help = "Register, update, or remove models from a specific LLM provider.";
        n.AddCommand<ListModels>();
        n.AddCommand<AddModel>();
        n.AddCommand<UpdateModel>();
        n.AddCommand<RemoveModel>();
        n.AddCommand<ViewModel>();
        n.AddCommand<HelpCommand>();
        n.AddCommand<BackCommand>();
        n.AddCommand<ExitCommand>();
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Showing Models main menu...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(ct);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }
}

---
Models\Commands\RemoveModel.cs
namespace Lola.Models.Commands;

public class RemoveModel(IHasChildren parent, IModelHandler handler)
    : LolaCommand<RemoveModel>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove a model";
        n.ErrorText = "removing a model";
        n.Help = "Remove a model.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->Remove command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            Logger.LogInformation("No models found. Remove model action cancelled.");
            return Result.Success();
        }
        var model = await this.SelectEntityAsync<ModelEntity, uint>(models.OrderBy(m => m.ProviderId).ThenBy(m => m.Name), m => m.Name, ct);
        if (model is null) {
            Logger.LogInformation("No model selected.");
            return Result.Success();
        }

        if (!await Input.ConfirmAsync($"Are you sure you want to remove the model '{model.Name}' ({model.Key})?", ct)) {
            return Result.Invalid("Action cancelled.");
        }

        handler.Remove(model.Id);
        Output.WriteLine($"[green]Settings with key '{model.Name}' removed successfully.[/]");
        return Result.Success();
    }
}

---
Models\Commands\SelectDefaultModel.cs
namespace Lola.Models.Commands;

public class SelectDefaultModel(IHasChildren parent, IModelHandler handler)
    : LolaCommand<SelectDefaultModel>(parent, "Select", n => {
        n.Aliases = ["sel"];
        n.Description = "Select default model.";
        n.ErrorText = "selecting the default model";
        n.Help = "Select the main model used by the app.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->Select default model command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models available. Please add a model before proceeding.[/]");
            return Result.Success();
        }

        var selected = await Input.BuildSelectionPrompt<ModelEntity>("Select an model:")
                                  .AddChoices(models.OrderBy(m => m.ProviderId).ThenBy(m => m.Name))
                                  .ConvertWith(c => c.Name)
                                  .ShowAsync(ct);

        handler.Select(selected.Id);
        Output.WriteLine($"[green]Settings '{selected.Key}' selected successfully.[/]");
        return Result.Success();
    }
}

---
Models\Commands\UpdateModel.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Models.Commands;

public class UpdateModel(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : LolaCommand<UpdateModel>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update model";
        n.ErrorText = "updating the model";
        n.Help = "Update an existing model.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->Update command...");
        var models = modelHandler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            Logger.LogInformation("No models found. Remove model action cancelled.");
            return Result.Success();
        }
        var model = await this.SelectEntityAsync<ModelEntity, uint>(models.OrderBy(m => m.ProviderId).ThenBy(m => m.Name), m => m.Name, ct);
        if (model is null) {
            Logger.LogInformation("No model selected.");
            return Result.Success();
        }

        await SetUpAsync(model, ct);
        modelHandler.Update(model);
        Logger.LogInformation("Settings '{ModelKey}:{ModelName}' updated successfully.", model.Key, model.Name);
        Output.WriteLine("[green]Settings updated successfully.[/]");
        return Result.Success();
    }

    private async Task SetUpAsync(ModelEntity model, CancellationToken ct) {
        var currentProvider = providerHandler.GetById(model.ProviderId);
        var provider = await Input.BuildSelectionPrompt<ProviderEntity>("Select a provider:")
                                  .ConvertWith(p => $"{p.Id}: {p.Name}")
                                  .WithDefault(currentProvider!)
                                  .AddChoices(providerHandler.List())
                                  .ShowAsync(ct);
        model.ProviderId = provider.Id;

        model.Key = await Input.BuildTextPrompt<string>("Enter the model identifier:")
                               .WithDefault(model.Key)
                               .AddValidation(key => ModelEntity.ValidateKey(model.Id, key, modelHandler))
                               .ShowAsync(ct);
        model.Name = await Input.BuildTextPrompt<string>("Enter the model name:")
                                .WithDefault(model.Name)
                                .AddValidation(name => ModelEntity.ValidateName(model.Id, name, modelHandler))
                                .ShowAsync(ct);
        model.MaximumContextSize = await Input.BuildTextPrompt<uint>("Enter the maximum context size:")
                                              .WithDefault(model.MaximumContextSize)
                                              .ShowAsync(ct);
        model.MaximumOutputTokens = await Input.BuildTextPrompt<uint>("Enter the maximum output tokens:")
                                               .WithDefault(model.MaximumOutputTokens)
                                               .ShowAsync(ct);
        model.InputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the input cost per million tokens:")
                                                     .WithDefault(model.InputCostPerMillionTokens)
                                                     .AddValidation(ModelEntity.ValidateInputCost)
                                                     .ShowAsync(ct);
        model.OutputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the output cost per million tokens:")
                                                      .WithDefault(model.OutputCostPerMillionTokens)
                                                      .AddValidation(ModelEntity.ValidateOutputCost)
                                                      .ShowAsync(ct);
        model.TrainingDateCutOff = await Input.BuildTextPrompt<DateOnly?>("Enter the training data cut-off date (YYYY-MM-DD):")
                                              .WithDefault(model.TrainingDateCutOff)
                                              .AddValidation(ModelEntity.ValidateDateCutOff)
                                              .ShowAsync(ct);
    }
}

---
Models\Commands\ViewModel.cs
namespace Lola.Models.Commands;

public class ViewModel(IHasChildren parent, IModelHandler handler, IProviderHandler providerHandler)
    : LolaCommand<ViewModel>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View model";
        n.ErrorText = "displaying the model information";
        n.Help = "Display detailed information about a model.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Models->Info command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            Logger.LogInformation("No models found. View model action cancelled.");
            return Result.Success();
        }
        var model = await this.SelectEntityAsync<ModelEntity, uint>(models.OrderBy(m => m.ProviderId).ThenBy(m => m.Name), m => m.Name, ct);
        if (model is null) {
            Logger.LogInformation("No model selected.");
            return Result.Success();
        }
        model.Provider = providerHandler.GetById(model.ProviderId)!;

        ShowDetails(model);

        return Result.Success();
    }

    private void ShowDetails(ModelEntity model) {
        Output.WriteLine("[yellow]Model Information:[/]");
        Output.WriteLine($"[blue]Id:[/] {model.Key}{(model.Selected ? " [green](default)[/]" : "")}");
        Output.WriteLine($"[blue]Name:[/] {model.Name}");
        Output.WriteLine($"[blue]Provider:[/] {model.Provider!.Name}");
        Output.WriteLine($"[blue]Maximum Map Size:[/] {model.MaximumContextSize}");
        Output.WriteLine($"[blue]Maximum Output Tokens:[/] {model.MaximumOutputTokens}");
        Output.WriteLine($"[blue]Input Cost per MTok:[/] {model.InputCostPerMillionTokens:C}");
        Output.WriteLine($"[blue]Output Cost per MTok:[/] {model.OutputCostPerMillionTokens:C}");
        Output.WriteLine($"[blue]Training Date Cut-Off:[/] {model.TrainingDateCutOff:MMM yyyy}");
        Output.WriteLine();
    }
}

---
Models\Handlers\IModelHandler.cs
namespace Lola.Models.Handlers;

public interface IModelHandler {
    ModelEntity[] List(uint providerKey = 0);
    ModelEntity? GetById(uint id);
    ModelEntity? Find(Expression<Func<ModelEntity, bool>> predicate);
    void Add(ModelEntity model);
    void Update(ModelEntity model);
    void Remove(uint id);

    void Select(uint id);
    ModelEntity? Selected { get; }
}

---
Models\Handlers\ModelHandler.cs
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Models.Handlers;

public class ModelHandler(IApplication application, IModelDataSource dataSource, Lazy<IProviderHandler> providerHandler, ILogger<ModelHandler> logger)
    : IModelHandler {
    private const string _applicationModelKey = "ApplicationModel";

    private ModelEntity? _selected;

    public ModelEntity? Selected {
        get => GetSelected();
        private set => SetSelected(IsNotNull(value));
    }

    private ModelEntity? GetSelected() {
        var cachedValue = application.Context.GetValueAs<ModelEntity>(_applicationModelKey);
        _selected = cachedValue ?? dataSource.GetSelected();
        if (_selected is null) return null;
        if (cachedValue is null) application.Context[_applicationModelKey] = _selected;
        return _selected; // Should only return null if the storage is empty or there is no selected model in the storage.
    }

    private void SetSelected(ModelEntity value) {
        if (value.Key == _selected?.Key) return;
        _selected = value;

        // Ensure record uniqueness in storage
        var oldSelectedModel = dataSource.FirstOrDefault(m => m.Selected);
        if (oldSelectedModel is not null && oldSelectedModel.Key != _selected.Key) {
            oldSelectedModel.Selected = false;
            dataSource.Update(oldSelectedModel);
        }
        _selected.Selected = true;
        dataSource.Update(_selected);

        // Update cached value
        application.Context[_applicationModelKey] = _selected;
    }

    public ModelEntity[] List(uint providerKey = 0)
        => [.. dataSource.GetAll(m => m.ProviderId == 0 || m.ProviderId == providerKey).OrderBy(m => m.Name)];

    public ModelEntity? GetById(uint id)
        => dataSource.FindById(id);

    public ModelEntity? Find(Expression<Func<ModelEntity, bool>> predicate)
        => dataSource.Find(predicate);

    public void Add(ModelEntity model) {
        if (_selected is null) model.Selected = true;
        var context = Map.FromMap([new(nameof(ModelHandler), this), new(nameof(ProviderHandler), providerHandler.Value)]);
        var result = dataSource.Add(model, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        _selected = model;
        logger.LogInformation("Added new model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public void Update(ModelEntity model) {
        if (dataSource.FindById(model.Id) == null)
            throw new InvalidOperationException($"Model with id '{model.Id}' not found.");

        var context = Map.FromMap([new(nameof(ModelHandler), this), new(nameof(ProviderHandler), providerHandler.Value)]);
        var result = dataSource.Update(model, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        logger.LogInformation("Updated model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public void Remove(uint id) {
        var model = dataSource.FindById(id, false) ?? throw new InvalidOperationException($"Model with id '{id}' not found.");

        dataSource.Remove(id);
        logger.LogInformation("Removed model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public ModelEntity[] ListByProvider(uint providerKey) => dataSource.GetAll(m => m.ProviderId == providerKey);

    public void Select(uint id) {
        var model = dataSource.FindById(id)
                 ?? throw new InvalidOperationException($"Model '{id}' not found.");
        Selected = model;
        logger.LogInformation("Model '{ModelKey} => {ModelName}' selected : ", model.Key, model.Name);
    }
}

---
Models\Repositories\IModelDataSource.cs
namespace Lola.Models.Repositories;

public interface IModelDataSource : IDataSource<ModelEntity, uint> {
    ModelEntity? GetSelected();
    ModelEntity[] GetAll(Expression<Func<ModelEntity, bool>>? predicate = null, bool includeProviders = true);
    ModelEntity? FindById(uint id, bool includeProvider = true);
}

---
Models\Repositories\IModelStorage.cs
namespace Lola.Models.Repositories;

public interface IModelStorage
    : IStorage<ModelEntity, uint>;

---
Models\Repositories\ModelDataSource.cs
namespace Lola.Models.Repositories;

public class ModelDataSource(IModelStorage storage, Lazy<IProviderDataSource> providers)
    : DataSource<IModelStorage, ModelEntity, uint>(storage),
      IModelDataSource {
    public ModelEntity[] GetAll(Expression<Func<ModelEntity, bool>>? predicate = null, bool includeProviders = true) {
        var models = base.GetAll(predicate);
        if (!includeProviders) return models;
        var providers1 = providers.Value.GetAll();
        foreach (var model in models)
            model.Provider = providers1.FirstOrDefault(p => p.Id == model.ProviderId);
        return models;
    }

    public ModelEntity? GetSelected() {
        var model = Find(m => m.Selected);
        if (model is null) return null;
        model.Provider = providers.Value.FindByKey(model.ProviderId);
        return model;
    }

    public ModelEntity? FindById(uint id, bool includeProvider = true) {
        var model = FindByKey(id);
        if (model is null) return null;
        if (!includeProvider) return model;
        model.Provider = providers.Value.FindByKey(model.ProviderId);
        return model;
    }
}

---
Models\Repositories\ModelEntity.cs
using Model = DotNetToolbox.AI.Models.Model;

namespace Lola.Models.Repositories;

public class ModelEntity : Entity<ModelEntity, uint> {
    public uint ProviderId { get; set; }
    [JsonIgnore]
    public ProviderEntity? Provider { get; set; }
    public string Key { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public uint MaximumContextSize { get; set; }
    public uint MaximumOutputTokens { get; set; }
    public decimal InputCostPerMillionTokens { get; set; }
    public decimal OutputCostPerMillionTokens { get; set; }
    public DateOnly? TrainingDateCutOff { get; set; }
    public bool Selected { get; set; }

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        var action = IsNotNull(context).GetRequiredValueAs<EntityAction>(nameof(EntityAction));
        result += ValidateKey(action == EntityAction.Insert ? null : Id, Key, context.GetRequiredValueAs<IModelHandler>(nameof(ModelHandler)));
        result += ValidateName(action == EntityAction.Insert ? null : Id, Name, context.GetRequiredValueAs<IModelHandler>(nameof(ModelHandler)));
        result += ValidateProvider(ProviderId, context.GetRequiredValueAs<IProviderHandler>(nameof(ProviderHandler)));
        result += ValidateInputCost(InputCostPerMillionTokens);
        result += ValidateOutputCost(OutputCostPerMillionTokens);
        result += ValidateDateCutOff(TrainingDateCutOff);
        return result;
    }

    public static Result ValidateKey(uint? id, string? key, IModelHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(key))
            result += new ValidationError("The key is required.", nameof(Key));
        else if (handler.Find(m => m.Key.Equals(key, StringComparison.OrdinalIgnoreCase) && (id == null || m.Id != id)) is not null)
            result += new ValidationError("A model with this key is already registered.", nameof(Key));
        return result;
    }

    public static Result ValidateName(uint? id, string? name, IModelHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.Find(m => m.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && (id == null || m.Id != id)) is not null)
            result += new ValidationError("A model with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateProvider(uint providerId, IProviderHandler handler) {
        var result = Result.Success();
        if (handler.GetById(providerId) is null)
            result += new ValidationError("The provider does not exist.", nameof(ProviderId));
        return result;
    }

    public static Result ValidateInputCost(decimal value) {
        var result = Result.Success();
        if (value < 0)
            result += new ValidationError("The input cost per million tokens must be greater than or equal to zero.", nameof(InputCostPerMillionTokens));
        return result;
    }

    public static Result ValidateOutputCost(decimal value) {
        var result = Result.Success();
        if (value < 0)
            result += new ValidationError("The input cost per million tokens must be greater than or equal to zero.", nameof(InputCostPerMillionTokens));
        return result;
    }

    public static Result ValidateDateCutOff(DateOnly? value) {
        var result = Result.Success();
        if (value is not null && value.Value > DateOnly.FromDateTime(DateTime.UtcNow))
            result += new ValidationError("The training data cut off date must be in the past.", nameof(TrainingDateCutOff));
        if (value is not null && value.Value <= DateOnly.Parse("2021-01"))
            result += new ValidationError("The training data cut off date must be after Jan. 2021.", nameof(TrainingDateCutOff));
        return result;
    }

    public static implicit operator Model(ModelEntity entity) => new(entity.Id) {
        Provider = entity.Provider!.Name,
        Key = entity.Key,
        Name = entity.Name,
        MaximumContextSize = entity.MaximumContextSize,
        MaximumOutputTokens = entity.MaximumOutputTokens,
        TrainingDataCutOff = entity.TrainingDateCutOff,
    };
}

---
Models\Repositories\ModelStorage.cs
namespace Lola.Models.Repositories;

public class ModelStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<ModelEntity, uint>("models", configuration),
      IModelStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}

---
Personas\Commands\AddPersona.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Personas.Commands;

public class AddPersona(IHasChildren parent, IPersonaHandler personaHandler)
    : LolaCommand<AddPersona>(parent, "Generate", n => {
        n.Aliases = ["gen"];
        n.Description = "Generate a new persona";
        n.ErrorText = "generating the new persona";
        n.Help = "Generate a new agent persona using AI assistance.";
    }) {
    private const int _maxQuestions = 10;

    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Personas->Generate command...");
        var persona = new PersonaEntity();
        await SetUpAsync(persona, ct);
        await AskAdditionalQuestions(persona, ct);
        await personaHandler.UpdateCreatedPersona(persona);

        Output.WriteLine($"[green]Agent persona '{persona.Name}' generated successfully.[/]");
        Logger.LogInformation("Persona '{PersonaId}:{PersonaName}' generated successfully.", persona.Id, persona.Name);

        ShowResult(persona);

        var savePersona = await Input.ConfirmAsync("Are you ok with the generated Agent above?", ct);
        if (savePersona) {
            personaHandler.Add(persona);
            Logger.LogInformation("Persona '{PersonaId}:{PersonaName}' added successfully.", persona.Id, persona.Name);
            return Result.Success();
        }

        Output.WriteLine("[yellow]Please review the provided answers and try again.[/]");
        return Result.Success();
    }

    private void ShowResult(PersonaEntity persona) {
        Output.WriteLine();
        Output.WriteLine($"[teal]Name:[/] {persona.Name}");
        Output.WriteLine($"[teal]Role:[/] {persona.Role}");
        Output.WriteLine("[teal]Goals:[/]");
        Output.WriteLine(string.Join("\n", persona.Goals.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Expertise:[/] [green](auto-generated)[/]");
        Output.WriteLine(persona.Expertise);
        Output.WriteLine("[teal]Characteristics:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Characteristics.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Requirements:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Requirements.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Restrictions:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Restrictions.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Traits:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Traits.Select(i => $" - {i}")));
        Output.WriteLine();
    }

    private async Task AskAdditionalQuestions(PersonaEntity persona, CancellationToken ct) {
        for (var questionCount = 0; questionCount < _maxQuestions; questionCount++) {
            Output.WriteLine("[yellow]Let me see if I have more questions...[/]");
            Output.WriteLine("[grey](You can skip the questions by typing 'proceed' at any time.)[/]");

            var queries = await personaHandler.GenerateQuestion(persona);
            if (queries.Length == 0) {
                Output.WriteLine("[green]I've gathered sufficient information to generate the agent's persona.[/]");
                break;
            }
            var proceed = false;
            foreach (var query in queries) {
                query.Answer = await Input.BuildMultilinePrompt($"Question {questionCount + 1}: {query.Question}")
                                          .ShowAsync(ct);
                if (query.Answer.Equals("proceed", StringComparison.OrdinalIgnoreCase)) {
                    proceed = true;
                    break;
                }
                persona.Questions.Add(query);
            }

            if (!proceed) continue;
            Output.WriteLine("[green]Ok. Let's proceed with the Agent's Persona generation.[/]");
            break;
        }
    }

    private async Task SetUpAsync(PersonaEntity persona, CancellationToken ct) {
        persona.Name = await Input.BuildTextPrompt<string>("How would you like to call the Agent?")
                                  .AddValidation(name => PersonaEntity.ValidateName(null, name, personaHandler))
                                  .ShowAsync(ct);
        persona.Role = await Input.BuildTextPrompt<string>($"What is the [white]{persona.Name}[/] primary role?")
                                  .AddValidation(PersonaEntity.ValidateRole)
                                  .ShowAsync(ct);

        var goal = await Input.BuildMultilinePrompt($"What is the Main Goal for the [white]{persona.Name}[/]?")
                              .AddValidation(PersonaEntity.ValidateGoal)
                              .ShowAsync(ct);
        persona.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
        var addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        while (addAnotherGoal) {
            goal = await Input.BuildMultilinePrompt("Additional goal: ")
                              .AddValidation(PersonaEntity.ValidateGoal)
                              .ShowAsync(ct);
            persona.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
            addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        }
    }
}

---
Personas\Commands\ListPersonas.cs
namespace Lola.Personas.Commands;

public class ListPersonas(IHasChildren parent, IPersonaHandler personaHandler)
    : LolaCommand<ListPersonas>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List existing personas";
        n.ErrorText = "listing personas";
        n.Help = "List all the existing agent's personas.";
    }) {
    protected override Result HandleCommand() {
        Logger.LogInformation("Executing Personas->List command...");
        var personas = personaHandler.List();

        if (personas.Length == 0) {
            Output.WriteLine("[yellow]No personas found.[/]");
            Output.WriteLine();

            return Result.Success();
        }

        var sortedList = personas.OrderBy(p => p.Name);
        ShowList(sortedList);

        return Result.Success();
    }

    private void ShowList(IEnumerable<PersonaEntity> personas) {
        var sortedPersonas = personas.OrderBy(m => m.Name);
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Role[/]"));
        table.AddColumn(new("[yellow]Main Goal[/]"));
        foreach (var persona in sortedPersonas)
            table.AddRow(persona.Name, persona.Role, persona.Goals.FirstOrDefault() ?? "[red][Undefined][/]");
        Output.Write(table);
    }
}

---
Personas\Commands\PersonasMainMenu.cs
namespace Lola.Personas.Commands;

public class PersonasMainMenu(IHasChildren parent)
    : LolaCommand<PersonasMainMenu>(parent, "Personas", n => {
        n.Description = "Manage Agent's Personas";
        n.ErrorText = "displaying the persona's main menu";
        n.AddCommand<ListPersonas>();
        n.AddCommand<AddPersona>();
        n.AddCommand<ViewPersona>();
        n.AddCommand<UpdatePersona>();
        n.AddCommand<RemovePersona>();
        n.AddCommand<HelpCommand>();
        n.AddCommand<BackCommand>();
        n.AddCommand<ExitCommand>();
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Personas->Main command...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.AsIndexed().OrderBy(i => i.Index).ToArray(c => c.Value.Name))
                                .ShowAsync(ct);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
                   ? Result.Success()
                   : await command.Execute([], ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }
}

---
Personas\Commands\RemovePersona.cs
namespace Lola.Personas.Commands;

public class RemovePersona(IHasChildren parent, IPersonaHandler handler)
    : LolaCommand<RemovePersona>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove a persona";
        n.ErrorText = "removing the persona";
        n.Help = "Remove an existing agent's persona.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Personas->Remove command...");
        var personas = handler.List();
        if (personas.Length == 0) {
            Output.WriteLine("[yellow]No personas found.[/]");
            Logger.LogInformation("No personas found. Remove persona action cancelled.");
            return Result.Success();
        }
        var persona = await this.SelectEntityAsync<PersonaEntity, uint>(personas.OrderBy(p => p.Name), p => p.Name, ct);
        if (persona is null) {
            Logger.LogInformation("No persona selected.");
            return Result.Success();
        }

        if (!await Input.ConfirmAsync($"Are you sure you want to remove the persona '{persona.Name}' ({persona.Id})?", ct)) {
            Logger.LogInformation("Persona removal cancelled by user.");
            return Result.Invalid("Action cancelled.");
        }

        handler.Remove(persona.Id);
        Output.WriteLine($"[green]Persona '{persona.Name}' removed successfully.[/]");
        Logger.LogInformation("Persona '{PersonaId}:{PersonaName}' removed successfully.", persona.Id, persona.Name);
        return Result.Success();
    }
}

---
Personas\Commands\UpdatePersona.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Personas.Commands;

public class UpdatePersona(IHasChildren parent, IPersonaHandler handler)
    : LolaCommand<UpdatePersona>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update a persona";
        n.ErrorText = "updating the persona";
        n.Help = "Update an existing agent's persona.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Personas->Update command...");
        var personas = handler.List();
        if (personas.Length == 0) {
            Output.WriteLine("[yellow]No personas found.[/]");
            Logger.LogInformation("No personas found. Update persona action cancelled.");
            return Result.Success();
        }
        var persona = await this.SelectEntityAsync<PersonaEntity, uint>(personas.OrderBy(p => p.Name), p => p.Name, ct);
        if (persona is null) {
            Logger.LogInformation("No persona selected.");
            return Result.Success();
        }

        await SetUpAsync(persona, ct);

        handler.Update(persona);
        Output.WriteLine($"[green]Persona '{persona.Name}' updated successfully.[/]");
        Logger.LogInformation("Persona '{PersonaId}:{PersonaName}' updated successfully.", persona.Id, persona.Name);
        return Result.Success();
    }

    private async Task SetUpAsync(PersonaEntity persona, CancellationToken ct) {
        // Update Name
        persona.Name = await Input.BuildTextPrompt<string>("- Name (ENTER to keep current):")
                                  .WithDefault(persona.Name)
                                  .ShowOptionalFlag()
                                  .AddValidation(name => PersonaEntity.ValidateName(persona.Id, name, handler))
                                  .ShowAsync(ct);

        // Update Role
        persona.Role = await Input.BuildTextPrompt<string>("- Role (ENTER to keep current):")
                                  .WithDefault(persona.Role)
                                  .ShowOptionalFlag()
                                  .AddValidation(PersonaEntity.ValidateRole)
                                  .ShowAsync(ct);

        // Update Goals
        Output.WriteLine($"This persona has currently {persona.Goals.Count} goals.");
        var goalCount = 0;
        while (goalCount < persona.Goals.Count) {
            persona.Goals[goalCount] = await Input.BuildMultilinePrompt($"- Goal {goalCount + 1}:")
                                                  .WithDefault(persona.Goals[goalCount])
                                                  .AddValidation(PersonaEntity.ValidateGoal)
                                                  .ShowAsync(ct);
            goalCount++;
        }
        var addGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        while (addGoal) {
            persona.Goals[goalCount] = await Input.BuildMultilinePrompt($"- Goal {goalCount + 1}:")
                                                  .AddValidation(PersonaEntity.ValidateGoal)
                                                  .ShowAsync(ct);
            addGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        }

        // Update Expertise
        persona.Expertise = await Input.BuildMultilinePrompt("- Agent Expertise:")
                                       .WithDefault(persona.Expertise)
                                       .ShowAsync(ct);

        // Update traits
        Output.WriteLine($"This persona has currently {persona.Characteristics.Count} characteristics.");
        var characteristicCount = 0;
        while (characteristicCount < persona.Characteristics.Count) {
            persona.Characteristics[characteristicCount] = await Input.BuildMultilinePrompt($"- Characteristic {characteristicCount + 1}:")
                                                   .WithDefault(persona.Characteristics[characteristicCount])
                                                   .AddValidation(PersonaEntity.ValidateCharacteristic)
                                                   .ShowAsync(ct);
            characteristicCount++;
        }
        var addCharacteristic = await Input.ConfirmAsync("Would you like to add another characteristic?", ct);
        while (addCharacteristic) {
            persona.Characteristics[characteristicCount] = await Input.BuildMultilinePrompt($"- Characteristic {characteristicCount + 1}:")
                                                   .AddValidation(PersonaEntity.ValidateCharacteristic)
                                                   .ShowAsync(ct);
            addCharacteristic = await Input.ConfirmAsync("Would you like to add another characteristic?", ct);
        }

        // Update Requirements
        Output.WriteLine($"This persona has currently {persona.Requirements.Count} requirements.");
        var requirementCount = 0;
        while (requirementCount < persona.Requirements.Count) {
            persona.Requirements[requirementCount] = await Input.BuildMultilinePrompt($"- Requirement {requirementCount + 1}:")
                                                   .WithDefault(persona.Requirements[requirementCount])
                                                   .AddValidation(PersonaEntity.ValidateRequirement)
                                                   .ShowAsync(ct);
            requirementCount++;
        }
        var addRequirement = await Input.ConfirmAsync("Would you like to add another requirement?", ct);
        while (addRequirement) {
            persona.Requirements[requirementCount] = await Input.BuildMultilinePrompt($"- Requirement {requirementCount + 1}:")
                                                   .AddValidation(PersonaEntity.ValidateRequirement)
                                                   .ShowAsync(ct);
            addRequirement = await Input.ConfirmAsync("Would you like to add another requirement?", ct);
        }

        // Update Restrictions
        Output.WriteLine($"This persona has currently {persona.Restrictions.Count} restrictions.");
        var restrictionCount = 0;
        while (restrictionCount < persona.Restrictions.Count) {
            persona.Restrictions[restrictionCount] = await Input.BuildMultilinePrompt($"- Restriction {restrictionCount + 1}:")
                                                         .WithDefault(persona.Restrictions[restrictionCount])
                                                         .AddValidation(PersonaEntity.ValidateRestriction)
                                                         .ShowAsync(ct);
            restrictionCount++;
        }
        var addRestriction = await Input.ConfirmAsync("Would you like to add another restriction?", ct);
        while (addRestriction) {
            persona.Restrictions[restrictionCount] = await Input.BuildMultilinePrompt($"- Restriction {restrictionCount + 1}:")
                                                         .AddValidation(PersonaEntity.ValidateRestriction)
                                                         .ShowAsync(ct);
            addRestriction = await Input.ConfirmAsync("Would you like to add another restriction?", ct);
        }

        // Update Traits
        Output.WriteLine($"This persona has currently {persona.Traits.Count} traits.");
        var traitCount = 0;
        while (traitCount < persona.Traits.Count) {
            persona.Traits[traitCount] = await Input.BuildMultilinePrompt($"- Traits {traitCount + 1}:")
                                                                .WithDefault(persona.Traits[traitCount])
                                                                .AddValidation(PersonaEntity.ValidateTrait)
                                                                .ShowAsync(ct);
            traitCount++;
        }
        var addTrait = await Input.ConfirmAsync("Would you like to add another trait?", ct);
        while (addTrait) {
            persona.Traits[traitCount] = await Input.BuildMultilinePrompt($"- Traits {traitCount + 1}:")
                                                                .AddValidation(PersonaEntity.ValidateTrait)
                                                                .ShowAsync(ct);
            addTrait = await Input.ConfirmAsync("Would you like to add another trait?", ct);
        }
    }
}

---
Personas\Commands\ViewPersona.cs
namespace Lola.Personas.Commands;

public class ViewPersona(IHasChildren parent, IPersonaHandler handler)
    : LolaCommand<ViewPersona>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View persona details";
        n.ErrorText = "displaying the persona information";
        n.Help = "Display detailed information about an agent's persona.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Personas->Info command...");
        var personas = handler.List();
        if (personas.Length == 0) {
            Output.WriteLine("[yellow]No personas found.[/]");
            Logger.LogInformation("No personas found. View persona action cancelled.");
            return Result.Success();
        }
        var persona = await this.SelectEntityAsync<PersonaEntity, uint>(personas.OrderBy(p => p.Name), p => p.Name, ct);
        if (persona is null) {
            Logger.LogInformation("No persona selected.");
            return Result.Success();
        }

        ShowDetails(persona);
        return Result.Success();
    }

    private void ShowDetails(PersonaEntity persona) {
        Output.WriteLine($"{persona.Name} [yellow]Information:[/]");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Role)}:[/]");
        Output.WriteLine(persona.Role);
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Expertise)}:[/]");
        Output.WriteLine(persona.Expertise);
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Goals)}:[/]");
        foreach (var goal in persona.Goals) Output.WriteLine($" - {goal}");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Characteristics)}:[/]");
        foreach (var characteristic in persona.Characteristics) Output.WriteLine($" - {characteristic}");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Requirements)}:[/]");
        foreach (var requirement in persona.Requirements) Output.WriteLine($" - {requirement}");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Restrictions)}:[/]");
        foreach (var restriction in persona.Restrictions) Output.WriteLine($" - {restriction}");
        Output.WriteLine();
        Output.WriteLine($"[blue]{nameof(Persona.Traits)}:[/]");
        foreach (var trait in persona.Traits) Output.WriteLine($" - {trait}");
        Output.WriteLine();
    }
}

---
Personas\Handlers\IPersonaHandler.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Personas.Handlers;

public interface IPersonaHandler {
    PersonaEntity[] List();
    PersonaEntity? GetById(uint id);
    PersonaEntity? Find(Expression<Func<PersonaEntity, bool>> predicate);
    void Add(PersonaEntity persona);
    void Update(PersonaEntity persona);
    void Remove(uint id);

    Task<Query[]> GenerateQuestion(PersonaEntity persona);
    Task UpdateCreatedPersona(PersonaEntity persona);
}

---
Personas\Handlers\PersonaHandler.cs
using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Personas.Handlers;

public class PersonaHandler(IServiceProvider services, ILogger<PersonaHandler> logger)
    : IPersonaHandler {
    private readonly IModelHandler _modelHandler = services.GetRequiredService<IModelHandler>();
    private readonly IUserProfileHandler _userHandler = services.GetRequiredService<IUserProfileHandler>();
    private readonly IPersonaDataSource _dataSource = services.GetRequiredService<IPersonaDataSource>();
    private readonly IJobHandler _jobHandler = services.GetRequiredService<IJobHandler>();
    private readonly IAgentAccessor _connectionAccessor = services.GetRequiredService<IAgentAccessor>();

    public PersonaEntity[] List() => _dataSource.GetAll();

    public PersonaEntity? GetById(uint id) => _dataSource.FindByKey(id);
    public PersonaEntity? Find(Expression<Func<PersonaEntity, bool>> predicate)
        => _dataSource.Find(predicate);

    public void Add(PersonaEntity persona) {
        if (_dataSource.FindByKey(persona.Id) != null)
            throw new InvalidOperationException($"A persona with the id '{persona.Id}' already exists.");

        var context = Map.FromMap([new(nameof(PersonaHandler), this)]);
        var result = _dataSource.Add(persona, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        logger.LogInformation("Added new persona: {PersonaId} => {PersonaName}", persona.Name, persona.Id);
    }

    public void Update(PersonaEntity persona) {
        if (_dataSource.FindByKey(persona.Id) == null)
            throw new InvalidOperationException($"Persona with id '{persona.Id}' not found.");

        var context = Map.FromMap([new(nameof(PersonaHandler), this)]);
        var result = _dataSource.Update(persona, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        logger.LogInformation("Updated persona: {PersonaId} => {PersonaName}", persona.Name, persona.Id);
    }

    public void Remove(uint id) {
        var persona = _dataSource.FindByKey(id)
                     ?? throw new InvalidOperationException($"Persona with id '{id}' not found.");

        _dataSource.Remove(id);
        logger.LogInformation("Removed persona: {PersonaId} => {PersonaName}", persona.Name, persona.Id);
    }

    public async Task<Query[]> GenerateQuestion(PersonaEntity persona) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = GetById(1) ?? throw new InvalidOperationException("Required persona not found. Name: 'Agent Creator'.");
            var taskEntity = _jobHandler.GetById(1) ?? throw new InvalidOperationException("Required task not found. Name: 'Ask Questions about the AI Agent'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = taskEntity,
                Input = persona,
            };
            var job = new Job(context);
            job.Converters.Add(typeof(List<Query>),
                               v => {
                                   var list = (List<Query>)v;
                                   if (list.Count == 0) return string.Empty;
                                   var sb = new StringBuilder();
                                   foreach (var item in list) {
                                       sb.AppendLine($"Q: {item.Question}");
                                       sb.AppendLine($"{item.Explanation}");
                                       sb.AppendLine($"A: {item.Answer}");
                                   }
                                   return sb.ToString();
                               });
            var result = await job.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            var response = context.OutputAsMap.GetList<Map>("Questions");
            return response.ToArray(i => new Query {
                Question = i.GetRequiredValueAs<string>(nameof(Query.Question)),
                Explanation = i.GetRequiredValueAs<string>(nameof(Query.Explanation)),
            });
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for persona {PersonaName}", persona.Name);
            throw;
        }
    }

    public async Task UpdateCreatedPersona(PersonaEntity persona) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = GetById(1) ?? throw new InvalidOperationException("Required persona not found. Name: 'Agent Creator'.");
            var taskEntity = _jobHandler.GetById(2) ?? throw new InvalidOperationException("Required task not found. Name: 'Ask Questions about the AI Agent'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = taskEntity,
                Input = persona,
            };
            var job = new Job(context);
            job.Converters.Add(typeof(List<Query>),
                               v => {
                                   var list = (List<Query>)v;
                                   if (list.Count == 0) return string.Empty;
                                   var sb = new StringBuilder();
                                   foreach (var item in list) {
                                       sb.AppendLine($"Q: {item.Question}");
                                       sb.AppendLine($"{item.Explanation}");
                                       sb.AppendLine($"A: {item.Answer}");
                                   }
                                   return sb.ToString();
                               });
            var result = await job.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            persona.Role = context.OutputAsMap.GetRequiredValueAs<string>(nameof(Persona.Role));
            persona.Goals = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Goals));
            persona.Expertise = context.OutputAsMap.GetRequiredValueAs<string>(nameof(Persona.Expertise));
            persona.Characteristics = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Characteristics));
            persona.Requirements = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Requirements));
            persona.Restrictions = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Restrictions));
            persona.Characteristics = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Traits));
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for persona {PersonaName}", persona.Name);
            throw;
        }
    }
}

---
Personas\Repositories\IPersonaDataSource.cs
namespace Lola.Personas.Repositories;

public interface IPersonaDataSource
    : IDataSource<PersonaEntity, uint>;

---
Personas\Repositories\IPersonaStorage.cs
namespace Lola.Personas.Repositories;

public interface IPersonaStorage
    : IStorage<PersonaEntity, uint>;

---
Personas\Repositories\PersonaDataSource.cs
namespace Lola.Personas.Repositories;

public class PersonaDataSource(IPersonaStorage storage)
    : DataSource<IPersonaStorage, PersonaEntity, uint>(storage),
      IPersonaDataSource;

---
Personas\Repositories\PersonaEntity.cs
namespace Lola.Personas.Repositories;

public class PersonaEntity
    : Entity<PersonaEntity, uint> {
    public string Name { get; set; } = string.Empty;
    public string Role { get; set; } = string.Empty;
    public List<string> Goals { get; set; } = [];

    public List<Query> Questions { get; init; } = [];

    public string Expertise { get; set; } = string.Empty;
    public List<string> Characteristics { get; set; } = [];
    public List<string> Requirements { get; set; } = [];
    public List<string> Restrictions { get; set; } = [];
    public List<string> Traits { get; set; } = [];

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        var action = IsNotNull(context).GetRequiredValueAs<EntityAction>(nameof(EntityAction));
        result += ValidateName(action == EntityAction.Insert ? null : Id, Name, context.GetRequiredValueAs<IPersonaHandler>(nameof(PersonaHandler)));
        result += ValidateRole(Role);
        result += ValidateGoals(Goals);
        return result;
    }

    public static implicit operator Map(PersonaEntity entity)
        => new() {
            ["Name"] = entity.Name,
            ["Role"] = entity.Role,
            ["Goals"] = entity.Goals,
            ["Questions"] = entity.Questions,
        };

    public static implicit operator Persona(PersonaEntity entity)
        => new(entity.Id) {
            Name = entity.Name,
            Role = entity.Role,
            Goals = entity.Goals,
            Expertise = entity.Expertise,
            Characteristics = entity.Characteristics,
            Requirements = entity.Requirements,
            Restrictions = entity.Restrictions,
            Traits = entity.Traits,
        };

    public static Result ValidateName(uint? id, string? name, IPersonaHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && (id == null || p.Id != id)) is not null)
            result += new ValidationError("A persona with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateRole(string? role) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(role))
            result += new ValidationError("The role is required.", nameof(Name));
        return result;
    }

    public static Result ValidateGoal(string? goal) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(goal))
            result += new ValidationError("The goal cannot be null or empty.", nameof(Goals));
        return result;
    }

    public static Result ValidateGoals(List<string> goals) {
        var result = Result.Success();
        if (goals.Count == 0)
            result += new ValidationError("At least one goal is required.", nameof(Goals));
        return goals.Aggregate(result, (current, goal) => current + ValidateGoal(goal));
    }

    public static Result ValidateCharacteristic(string? characteristic) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(characteristic))
            result += new ValidationError("The characteristic cannot be null or empty.", nameof(Characteristics));
        return result;
    }

    public static Result ValidateCharacteristics(List<string> characteristics) {
        var result = Result.Success();
        return characteristics.Aggregate(result, (current, characteristic) => current + ValidateCharacteristic(characteristic));
    }

    public static Result ValidateRequirement(string? requirement) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(requirement))
            result += new ValidationError("The requirement cannot be null or empty.", nameof(Requirements));
        return result;
    }

    public static Result ValidateRequirements(List<string> requirements) {
        var result = Result.Success();
        return requirements.Aggregate(result, (current, requirement) => current + ValidateRequirement(requirement));
    }

    public static Result ValidateRestriction(string? restriction) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(restriction))
            result += new ValidationError("The restriction cannot be null or empty.", nameof(Restrictions));
        return result;
    }

    public static Result ValidateRestrictions(List<string> restrictions) {
        var result = Result.Success();
        return restrictions.Aggregate(result, (current, restriction) => current + ValidateRestriction(restriction));
    }

    public static Result ValidateTrait(string? trait) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(trait))
            result += new ValidationError("The trait cannot be null or empty.", nameof(Characteristics));
        return result;
    }

    public static Result ValidateTraits(List<string> traits) {
        var result = Result.Success();
        return traits.Aggregate(result, (current, trait) => current + ValidateTrait(trait));
    }
}

---
Personas\Repositories\PersonaStorage.cs
namespace Lola.Personas.Repositories;

public class PersonaStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<PersonaEntity, uint>("personas", configuration),
      IPersonaStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}

---
Personas\Repositories\Query.cs
namespace Lola.Personas.Repositories;

public class Query {
    public string Question { get; set; } = string.Empty;
    public string Explanation { get; set; } = string.Empty;
    public string Answer { get; set; } = string.Empty;
}

---
Providers\Commands\AddProvider.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Providers.Commands;

public class AddProvider(IHasChildren parent, IProviderHandler handler)
    : LolaCommand<AddProvider>(parent, "Add", n => {
        n.Aliases = ["new"];
        n.Description = "Add a provider";
        n.ErrorText = "adding the new provider";
        n.Help = "Register a new LLM provider to use with your AI agents.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Providers->Add command...");
        var provider = new ProviderEntity();
        await SetUpAsync(provider, ct);
        handler.Add(provider);
        Output.WriteLine($"[green]Provider '{provider.Name}' added successfully.[/]");
        Logger.LogInformation("Provider '{ProviderId}:{ProviderName}' added successfully.", provider.Id, provider.Name);
        return Result.Success();
    }

    private async Task SetUpAsync(ProviderEntity provider, CancellationToken ct) {
        provider.Name = await Input.BuildMultilinePrompt("What is the name of the LLM provider?")
                                   .AsSingleLine()
                                   .AddValidation(n => ProviderEntity.ValidateName(null, n, handler))
                                   .ShowAsync(ct);

        if (await Input.ConfirmAsync("Do you have an API Key for this provider?", ct)) {
            provider.ApiKey = await Input.BuildMultilinePrompt("API Key:")
                                         .AsSingleLine()
                                         .AddValidation(ProviderEntity.ValidateApiKey)
                                         .ShowAsync(ct);

            if (!string.IsNullOrWhiteSpace(provider.ApiKey))
                provider.IsEnabled = await Input.ConfirmAsync("Do you want to enable this provider now?", ct);
        }
    }
}

---
Providers\Commands\ListProviders.cs
namespace Lola.Providers.Commands;

public class ListProviders(IHasChildren parent, IProviderHandler providerHandler)
    : LolaCommand<ListProviders>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List all providers";
        n.ErrorText = "listing the existing providers";
        n.Help = "List all LLM providers.";
    }) {
    protected override Result HandleCommand() {
        Logger.LogInformation("Executing Providers->List command...");
        var providers = providerHandler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No providers found.[/]");
            Logger.LogInformation("No providers found. List providers action cancelled.");
            return Result.Success();
        }

        var sortedList = providers.OrderBy(p => p.Name);
        ShowList(sortedList);

        Logger.LogInformation("Providers listed.");
        return Result.Success();
    }

    private void ShowList(IEnumerable<ProviderEntity> providers) {
        var table = new Table();
        table.AddColumn(new("[yellow]Id[/]"));
        table.AddColumn(new("[yellow]Name[/]"));
        foreach (var provider in providers) {
            table.AddRow(provider.Id.ToString(), provider.Name);
        }

        Output.Write(table);
    }
}

---
Providers\Commands\ProvidersMainMenu.cs
namespace Lola.Providers.Commands;

public class ProvidersMainMenu(IHasChildren parent)
    : LolaCommand<ProvidersMainMenu>(parent, "Providers", n => {
        n.Description = "Manage LLM Providers";
        n.Help = "Register, update, or remove LLM providers.";
        n.ErrorText = "displaying provider's main menu";
        n.AddCommand<ListProviders>();
        n.AddCommand<AddProvider>();
        n.AddCommand<ViewProvider>();
        n.AddCommand<UpdateProvider>();
        n.AddCommand<RemoveProvider>();
        n.AddCommand<HelpCommand>();
        n.AddCommand<BackCommand>();
        n.AddCommand<ExitCommand>();
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Showing Providers main menu...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(ct);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }
}

---
Providers\Commands\RemoveProvider.cs
namespace Lola.Providers.Commands;

public class RemoveProvider(IHasChildren parent, IProviderHandler handler, IModelHandler modelHandler)
    : LolaCommand<RemoveProvider>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove a provider";
        n.ErrorText = "removing the LLM provider";
        n.Help = "Remove a LLM provider.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Providers->Remove command...");
        var result = await SelectProvider(ct);
        if (!result.IsSuccess) return result;
        var provider = result.Value;

        var models = modelHandler.List(provider.Id);
        if (models.Length > 0) {
            Output.WriteLine("[yellow bold]The following model(s) will also be deleted.[/]");
            ShowList(models);
        }

        if (!Input.Confirm($"Are you sure you want to delete '{provider.Name}' ({provider.Id})?")) {
            Logger.LogInformation("Provider remove action cancelled.");
            return Result.Success();
        }

        handler.Remove(provider.Id);
        Output.WriteLine($"[green]Provider with id '{provider.Name}' removed successfully.[/]");
        Logger.LogInformation("Provider '{ProviderId}:{ProviderName}' removed successfully.", provider.Id, provider.Name);
        return Result.Success();
    }

    private async Task<Result<ProviderEntity>> SelectProvider(CancellationToken lt) {
        var providers = handler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No LLM providers found.[/]");
            Logger.LogInformation("No LLM providers found.");
            return Result.Invalid<ProviderEntity>(new ValidationError("No LLM providers found."));
        }
        var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, lt);
        if (provider is null) {
            Logger.LogInformation("No LLM provider selected.");
            return Result.Invalid<ProviderEntity>(new ValidationError("No LLM provider selected."));
        }
        return Result.Success(provider);
    }

    private void ShowList(ModelEntity[] models) {
        var table = new Table();
        table.AddColumn("Id");
        table.AddColumn("Key");
        table.AddColumn("Name");
        foreach (var model in models) {
            table.AddRow($"{model.Id}", model.Key, model.Name);
        }
        Output.Write(table);
    }
}

---
Providers\Commands\UpdateProvider.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.Providers.Commands;

public class UpdateProvider(IHasChildren parent, IProviderHandler handler)
    : LolaCommand<UpdateProvider>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update a provider";
        n.ErrorText = "updating the LLM provider";
        n.Help = "Update a LLM provider.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Providers->Update command...");
        var providers = handler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No providers found.[/]");
            Logger.LogInformation("No providers found. Remove provider action cancelled.");
            return Result.Success();
        }
        var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, ct);
        if (provider is null) {
            Logger.LogInformation("Provider updated action cancelled.");
            return Result.Success();
        }
        await SetUpAsync(provider, ct);

        handler.Update(provider);
        Output.WriteLine($"[green]Provider '{provider.Name}' updated successfully.[/]");
        Logger.LogInformation("Provider '{ProviderId}:{ProviderName}' updated successfully.", provider.Id, provider.Name);
        return Result.Success();
    }

    private async Task SetUpAsync(ProviderEntity provider, CancellationToken ct) {
        provider.Name = await Input.BuildMultilinePrompt("Enter the new name for the provider")
                                   .WithDefault(provider.Name)
                                   .AsSingleLine()
                                   .AddValidation(name => ProviderEntity.ValidateName(provider.Id, name, handler))
                                   .ShowAsync(ct);

        if (string.IsNullOrWhiteSpace(provider.ApiKey)) {
            if (await Input.ConfirmAsync("Do you have an API Key for this provider?", ct)) {
                provider.ApiKey = await Input.BuildMultilinePrompt("API Key:")
                                             .AsSingleLine()
                                             .AddValidation(ProviderEntity.ValidateApiKey)
                                             .ShowAsync(ct);
            }
            provider.IsEnabled = false;
            return;
        }

        if (await Input.ConfirmAsync("Do you want to change or remove the API Key?", ct)) {
            provider.ApiKey = await Input.BuildMultilinePrompt("New API Key [yellow](clear the value to remove it)[/]:")
                                         .AsSingleLine()
                                         .WithDefault(provider.ApiKey)
                                         .ShowAsync(ct);
        }

        if (!string.IsNullOrWhiteSpace(provider.ApiKey)) {
            var message = provider.IsEnabled
                              ? "Do you want to keep this provider enabled?"
                              : "Do you want to activate this provider?";
            provider.IsEnabled = await Input.ConfirmAsync(message, ct);
            return;
        }

        if (provider.IsEnabled)
            provider.IsEnabled = false;
    }
}

---
Providers\Commands\ViewProvider.cs
namespace Lola.Providers.Commands;

public class ViewProvider(IHasChildren parent, IProviderHandler handler)
    : LolaCommand<ViewProvider>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View a provider";
        n.ErrorText = "displaying the provider";
        n.Help = "Display the detailed information about a LLM Provider.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing Providers->View command...");
        var providers = handler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No providers found.[/]");
            Logger.LogInformation("No providers found. View provider action cancelled.");
            return Result.Success();
        }

        var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, ct);
        if (provider is null) {
            Logger.LogInformation("No provider selected.");
            return Result.Success();
        }

        ShowDetails(provider);
        return Result.Success();
    }

    private void ShowDetails(ProviderEntity provider) {
        Output.WriteLine("[yellow]Provider Information:[/]");
        Output.WriteLine($"[blue]Name:[/] {provider.Name}");
        Output.WriteLine($"[blue]API Id:[/] {provider.ApiKey ?? "[red]Not Set[/]"}");
    }
}

---
Providers\Handlers\IProviderHandler.cs
namespace Lola.Providers.Handlers;

public interface IProviderHandler {
    ProviderEntity[] List();
    ProviderEntity? GetById(uint id);
    ProviderEntity? Find(Expression<Func<ProviderEntity, bool>> predicate);
    void Add(ProviderEntity provider);
    void Update(ProviderEntity provider);
    void Remove(uint id);
}

---
Providers\Handlers\ProviderHandler.cs
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Providers.Handlers;

public class ProviderHandler(IProviderDataSource dataSource, Lazy<IModelHandler> modelHandler, ILogger<ProviderHandler> logger)
    : IProviderHandler {
    public ProviderEntity[] List() => dataSource.GetAll();

    public ProviderEntity? GetById(uint id) => dataSource.FindByKey(id);
    public ProviderEntity? Find(Expression<Func<ProviderEntity, bool>> predicate) => dataSource.Find(predicate);

    public void Add(ProviderEntity provider) {
        if (GetById(provider.Id) != null)
            throw new ValidationException($"A provider with the id '{provider.Id}' already exists.");

        var context = Map.FromMap([new(nameof(ProviderHandler), this)]);
        var result = dataSource.Add(provider, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        logger.LogInformation("Added new provider: {ProviderId} => {ProviderName}", provider.Name, provider.Id);
    }

    public void Update(ProviderEntity provider) {
        if (GetById(provider.Id) is null)
            throw new ValidationException($"Provider with id '{provider.Id}' not found.");

        var context = Map.FromMap([new(nameof(ProviderHandler), this)]);
        var result = dataSource.Update(provider, context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);
        logger.LogInformation("Updated provider: {ProviderId} => {ProviderName}", provider.Name, provider.Id);
    }

    public void Remove(uint id) {
        var provider = GetById(id) ?? throw new ValidationException($"Provider with id '{id}' not found.");

        var models = modelHandler.Value.List(provider.Id);
        foreach (var model in models) {
            modelHandler.Value.Remove(model.Id);
        }
        logger.LogInformation("Removed all models from provider: {ProviderId}", id);

        dataSource.Remove(id);
        logger.LogInformation("Removed provider: {ProviderId} => {ProviderName}", provider.Name, provider.Id);
    }
}

---
Providers\Repositories\IProviderDataSource.cs
namespace Lola.Providers.Repositories;

public interface IProviderDataSource
    : IDataSource<ProviderEntity, uint>;

---
Providers\Repositories\IProviderStorage.cs
namespace Lola.Providers.Repositories;

public interface IProviderStorage
    : IStorage<ProviderEntity, uint>;

---
Providers\Repositories\ProviderDataSource.cs
namespace Lola.Providers.Repositories;

public sealed class ProviderDataSource(IProviderStorage storage)
    : DataSource<IProviderStorage, ProviderEntity, uint>(storage),
      IProviderDataSource;

---
Providers\Repositories\ProviderEntity.cs
namespace Lola.Providers.Repositories;

public class ProviderEntity
    : Entity<ProviderEntity, uint> {
    public string Name { get; set; } = string.Empty;
    public bool IsEnabled { get; set; }
    public string? ApiKey { get; set; }

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        var action = IsNotNull(context).GetRequiredValueAs<EntityAction>(nameof(EntityAction));
        result += ValidateName(action == EntityAction.Insert ? null : Id, Name, context.GetRequiredValueAs<IProviderHandler>(nameof(ProviderHandler)));
        return result;
    }

    public static Result ValidateName(uint? id, string? name, IProviderHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && (id == null || p.Id != id)) is not null)
            result += new ValidationError("A provider with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateApiKey(string? apiKey) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(apiKey))
            result += new ValidationError("The API Key is required.", nameof(Name));
        return result;
    }
}

---
Providers\Repositories\ProviderStorage.cs
namespace Lola.Providers.Repositories;

public sealed class ProviderStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<ProviderEntity, uint>("providers", configuration),
      IProviderStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}

---
saved\agents.json
[]
---
saved\models.json
[
  {
    "Id": 1,
    "ProviderId": 1,
    "Name": "GPT-4o",
    "MaximumContextSize": 128000,
    "MaximumOutputTokens": 4096,
    "InputCostPerMillionTokens": 5,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2023-10-01",
    "Selected": false,
    "Key": "gpt-4o"
  },
  {
    "Id": 2,
    "ProviderId": 2,
    "Name": "Claude 3.5 Sonnet",
    "MaximumContextSize": 200000,
    "MaximumOutputTokens": 8192,
    "InputCostPerMillionTokens": 3,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2024-04-01",
    "Selected": true,
    "Key": "claude-3-5-sonnet-20240620"
  }
]
---
saved\personas.json
[
  {
    "Name": "Agent Creator",
    "Role": "AI Agent Description Specialist",
    "Goals": [
      "create detailed, accurate, and tailored descriptions for various AI agents"
    ],
    "Questions": [],
    "Expertise": "AI capabilities, roles, and effective prompt engineering",
    "Characteristics": [
      "You carefully break down requirements and information to create comprehensive agent descriptions.",
      "You can create descriptions for a wide range of AI agent types and purposes.",
      "You ensure all aspects of an agent\u0027s role and capabilities are highly detailed and clearly defined.",
      "You can come up with unique and effective ways to describe AI agents\u0027 functions and limitations.",
      "You prioritize clear, concise, and unambiguous language in your descriptions.",
      "You are able to adapt your descriptions to different contexts and requirements."
    ],
    "Requirements": [
      "always prioritize clarity and specificity in your agent descriptions.",
      "include both capabilities and limitations in every agent description.",
      "ensure that the descriptions you create are ethically sound and promote responsible AI use."
    ],
    "Restrictions": [
      "create descriptions for AI agents that could be used for harmful or illegal purposes",
      "misrepresent an AI agent\u0027s capabilities or limitations",
      "use ambiguous or vague language in your descriptions"
    ],
    "Traits": [
      "You have extensive knowledge of various AI models and their capabilities.",
      "You understand the importance of ethical AI behavior and incorporate this into your descriptions.",
      "You are familiar with different domains and can tailor agent descriptions to specific fields."
    ],
    "Id": 1
  },
  {
    "Name": "Master Coder",
    "Role": "Senior .NET C# Full-Stack Developer",
    "Goals": [
      "Produce high-quality software according to the USER\u0027s requirements using the best coding practices."
    ],
    "Questions": [
      {
        "Question": "What specific areas of .NET and C# development should Master Coder specialize in? (e.g., ASP.NET Core, WPF, Xamarin, Entity Framework, etc.)",
        "Explanation": "This will help define the agent\u0027s expertise within the .NET ecosystem and ensure it can provide targeted assistance in relevant technologies.",
        "Answer": "All of them. He should have expertise in all of the C# .Net platform."
      }
    ],
    "Expertise": "You are an expert in all aspects of the C# .NET platform, including but not limited to ASP.NET Core, WPF, Xamarin, Entity Framework, and traits related technologies.",
    "Characteristics": [
      "Versatile: You are proficient in multiple technologies within the .NET ecosystem, allowing you to tackle diverse programming challenges.",
      "Detail-oriented: You pay close attention to code quality, structure, and performance optimizations.",
      "Problem-solver: You excel at breaking down complex software requirements into manageable components and finding effective solutions.",
      "Continuous learner: You stay updated with the latest developments in .NET and C# technologies to maintain your expertise."
    ],
    "Requirements": [
      "You MUST always prioritize writing clean, maintainable, and efficient code.",
      "ALWAYS adhere to best coding practices and design patterns appropriate for .NET and C# development.",
      "You MUST provide clear explanations and justifications for your code design decisions.",
      "ALWAYS consider scalability, security, and performance in your software solutions."
    ],
    "Restrictions": [
      "produce code that is insecure, inefficient, or fails to meet the USER\u0027s requirements.",
      "ignore or dismiss best practices in software development and .NET programming.",
      "provide outdated or deprecated solutions without explicitly mentioning their status.",
      "skip proper error handling and input validation in your code examples or suggestions."
    ],
    "Traits": [
      "Familiar with agile development methodologies",
      "Capable of providing guidance on software architecture and system design",
      "Knowledgeable about database design and optimization for .NET applications",
      "Experienced in integrating third-party APIs and services into .NET applications"
    ],
    "Id": 2
  }
]
---
saved\providers.json
[
  {
    "Name": "OpenAI",
    "Id": 1
  },
  {
    "Name": "Anthropic",
    "Id": 2
  }
]
---
saved\tasks.json
[
  {
    "Assumptions": [
      "The user has already provided a Name, Role, and list of Goals for the AI agent",
      "The user may not be an expert in AI or agent design, so questions should be clear and avoid overly technical jargon",
      "The questions generated will be used in a subsequent step to create a full agent description",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "make assumptions about the agent's capabilities beyond what is explicitly stated in the provided information",
      "generate questions about technical implementation details that the average user wouldn't be able to answer",
      "include questions that have already been answered by the provided Name, Role, and Goals",
      "include questions that were already answered by the user in a previous interaction"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalized advice on reducing carbon footprint\n2. Educate users on environmental issues\n3. Suggest eco-friendly alternatives for daily activities\n\nResponse:\n{\"Questions\":[{\"Question\":\"What level of expertise should EcoAdvise have? (e.g., general knowledge, academic-level, or industry-expert level)\",\"Explanation\":\"This will help determine the depth and complexity of advice the agent can provide.\"}]}",
      "Input:\nName: CodeCraft\nRole: Programming Assistant\nGoals:\n1. Help users debug their code\n2. Explain programming concepts\n3. Suggest optimizations for code efficiency\nPrevious Questions:\nQ: What programming languages should CodeCraft be proficient in?\nThis will define the scope of the agent's expertise and ensure it can assist with relevant languages.\nA: C# .NET\n\nResponse:\n{\"Questions\":[{\"Question\":\"Should CodeCraft be able to generate code snippets or complete functions, or only provide guidance?\",\"Explanation\":\"This will clarify the extent of the agent's coding capabilities and set appropriate user expectations.\"}]}"
    ],
    "Guidelines": [
      "Begin by carefully analyzing the provided Name, Role, and Goals to understand the general direction of the agent.",
      "Generate questions that cover different aspects of the agent, such as:\n- Specific capabilities within the given role;\n- Intended user interaction style;\n- Ethical guidelines and limitations;\n- Knowledge base and areas of expertise; and\n- Personality traits or communication style;",
      "Ensure questions are open-ended to encourage detailed responses.",
      "Frame questions in a way that helps users think deeply about their agent's design.",
      "Include a mix of questions about both capabilities and limitations."
    ],
    "Goals": [
      "generate insightful and relevant questions that will help users further define the characteristics, capabilities, and limitations of the AI agent they want to create",
      "analyze the provided Name, Role, and Goals of the prospective AI agent",
      "identify areas where more information is needed to create a comprehensive agent description",
      "generate clear, specific questions that will elicit useful information from the user",
      "ensure that the questions cover a wide range of agent characteristics, including capabilities, limitations, ethical considerations, and interaction style",
      "adapt the questions based on the context provided by the initial input"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nPrevious Questions:\n<<Questions>>\n",
    "Internal": true,
    "Id": 1,
    "Name": "Ask Questions about the AI Agent",
    "Scope": [
      "generating questions based solely on the Name, Role, and Goals provided by the user",
      "focusing on aspects of the agent that are not fully clear from the initial information",
      "covering various aspects of agent design, including but not limited to: knowledge base, interaction style, ethical guidelines, specific capabilities, and limitations"
    ],
    "Requirements": [
      "generate ONE question per request",
      "generate questions directly relevant to the provided Name, Role, and Goals",
      "generate questions designed to elicit specific, actionable information for agent creation",
      "generate an output that is a valid JSON file following strictly the schema defined in the prompt"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Questions\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"Question\":{\"type\":\"string\"},\"Explanation\":{\"type\":\"string\"}},\"required\":[\"Explanation\",\"Question\"]}}}}",
    "ResponseType": "Json",
    "Validations": [
      "Ensuring each question is directly relevant to the provided Name, Role, and Goals",
      "Checking that the set of questions covers a diverse range of agent characteristics",
      "Verifying that each question is clear, concise, and likely to elicit useful information",
      "Confirming that the questions do not make unwarranted assumptions about the agent",
      "Reviewing the brief explanations to ensure they clearly convey why each question is important"
    ]
  },
  {
    "Assumptions": [
      "The user has provided a Name, Role, and list of Goals for the AI agent",
      "The user has answered additional questions about the AI agent",
      "All provided information is relevant to the Persona creation",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "introduce new information that isn't derived from the user's input or question responses",
      "generate properties that contradict the provided Name, Role, Goals or Answered Questions",
      "include traits in multiple categories (e.g., a trait shouldn't appear in both Traits and Important lists)"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalised advice at reducing carbon footprint\n2. Educate the users on environmental issues\n3. Suggest eco-friendly alternative for daiyl activities\nQuestions:\nQ: What level of expertise should EcoAdvise have?\nThis question will help identify the scope and depth of the knowledge that the agent have.\nA: EcoAdvise should have industry-expert level knowledge.\nQ: How should EcoAdvise balance between providing scientific facts and motivating users?\nThis question will help define the type of answer the user is expecting.\nA: EcoAdvise should use a 70-30 split, with 70% focus on scientific facts and 30% on motivation.\n\nOutput:\n{\"Role\":\"Environmental Sustainability Consultant\",\"Goals\":[\"Provide personalized advice on reducing carbon footprint\",\"Educate the user on environmental issues\",\"Suggest eco-friendly alternatives for daily activities\"],\"Expertise\":\"Advanced environmental science with a focus on sustainability and carbon footprint reduction\",\"Traits\":[\"Broadly Knowlegeable: Knowledgeable about global and local environmental issues\",\"Excellent Communicator: Able to communicate complex scientific concepts clearly\",\"Data-Driven: Data-driven in approach to sustainability\"],\"Important\":[\"You MUST provide accurate, up-to-date environmental information\",\"ALWAYS respects user privacy when handling location data\",\"You MUST balances scientific facts with motivational encouragement\"],\"Negative\":[\"be alarmist or overly pessimistic about environmental issues\",\"recommend unsustainable or unethical practices\",\"ignore local context in sustainability advice\"],\"Other\":[\"Uses a 70-30 split between scientific facts and motivation in communications\",\"Capable of tailoring advice to specific geographic locations\",\"Stays updated on the latest environmental research and sustainability practices\"]}\n"
    ],
    "Guidelines": [
      "Begin by carefully analyzing all provided information: Name, Role, Goals, and question responses",
      "For Expertise, identify the core area of knowledge or skill central to the Persona's role and goals",
      "For Traits, identify characteristics that support the Persona's role and goals but aren't crucial",
      "For Important, identify crucial characteristics without which the Persona couldn't fulfill its role or achieve its goals",
      "For Negative, identify traits or behaviors that would hinder the Persona's effectiveness or contradict its purpose",
      "For Other, include any relevant information that doesn't fit into the above categories but adds depth to the Persona",
      "Ensure all generated properties align with the Persona's Name, Role, and Goals",
      "Provide clear, concise explanations for each generated property"
    ],
    "Goals": [
      "generate the Expertise, Traits, Important, Negative, and Other properties of the Persona",
      "ensure that the generated properties are consistent with the initial input and question responses",
      "create a comprehensive and coherent Persona description",
      "provide explanations for each generated property to justify its relevance to the Persona"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nQuestions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 2,
    "Name": "Generate AI Agent Persona",
    "Scope": [
      "generating the Expertise, Traits, Important, Negative, and Other properties based solely on the provided information",
      "ensuring all generated properties align with the Persona's Name, Role, and Goals",
      "focusing on creating a well-rounded and consistent Persona description"
    ],
    "Requirements": [
      "generate all five properties: Expertise, Traits, Important, Negative, and Other",
      "rewrite the Role and Goals properties with correct English without changing their intended contents",
      "ensure the Role property is a text that is a continuation of: 'You are a highly capable and versatile {Role}'",
      "ensure that each Goal is a simple phrase that is a continuation of: 'Your goal is {Goal}'",
      "ensure the Expertise property is a text describing list of skills the agent and is a continuation of 'You are an expert in {Expertise}'",
      "ensure the Traits, Important, Negative, and Other properties are lists of strings",
      "ensure that each Trait also include a short explanation of their intent. For example:\n Highly Analytical: You meticulously break down complex programming problems and user requirements to provide comprehensive solutions and explanations.\n Excellent Communicator: You explain complex technical concepts and code structures in clear, accessible language tailored to the USER's level of understanding.",
      "ensure that the Important and Negative lists do not contradict each other",
      "ensure that each Important item is written in an imperative way as continuation of the text: '**IMPORTANT, ** {Important_Item}'. They should normally start with 'You MUST ' or 'ALWAYS '.",
      "ensure that each Negative item is written as their POSITIVE version as a continuation of the text: '**NEVER, IN ANY CIRCUMSTANCE, ** {Negative_Item}'",
      "provide a brief explanation for each generated property, justifying its relevance to the Persona"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Role\":{\"type\":\"string\"},\"Goals\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Expertise\":{\"type\":\"string\"},\"Traits\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Important\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Negative\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Other\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"Role\",\"Goals\",\"Expertise\",\"Traits\",\"Important\",\"Negative\",\"Other\"]}",
    "ResponseType": "Json",
    "Validations": [
      "ensuring each generated property is directly relevant to and consistent with the provided information",
      "checking that the Expertise aligns closely with the Role and Goals",
      "verifying that Traits and Important lists contain distinct items that don't contradict each other",
      "confirming that Negative traits are genuinely detrimental to the Persona's purpose",
      "reviewing the Other list to ensure it adds value without redundancy",
      "validating that clear, concise explanations are provided for each generated property"
    ]
  }
]

---
saved\users.json
[
  {
    "Internal": true,
    "Name": "User",
    "Id": 0
  },
  {
    "Internal": false,
    "Name": "Argus",
    "Id": 1
  }
]
---
UserProfile\Commands\UpdateUserProfile.cs
using Task = System.Threading.Tasks.Task;

namespace Lola.UserProfile.Commands;

public class UpdateUserProfile(IHasChildren parent, IUserProfileHandler handler)
    : LolaCommand<UpdateUserProfile>(parent, "Change", n => {
        n.Aliases = ["set"];
        n.ErrorText = "setting the user profile";
        n.Description = "Update your profile.";
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing UserProfile->Set command...");
        var user = handler.CurrentUser ?? handler.Create();
        await SetUpAsync(user, ct);
        handler.Set(user);

        Output.WriteLine("[green]User profile set successfully.[/]");
        Logger.LogInformation("User profile set successfully.");
        return Result.Success();
    }

    private async Task SetUpAsync(UserProfileEntity user, CancellationToken ct)
        => user.Name = await Input.BuildTextPrompt<string>("How would you like me to call you?")
                                  .AddValidation(UserProfileEntity.ValidateName)
                                  .ShowAsync(ct);
}

---
UserProfile\Commands\UserProfileMainMenu.cs
namespace Lola.UserProfile.Commands;

public class UserProfileMainMenu(IHasChildren parent)
    : LolaCommand<UserProfileMainMenu>(parent, "UserProfile", n => {
        n.Description = "Manage Your Profile";
        n.ErrorText = "displaying the user profile main menu";
        n.AddCommand<UpdateUserProfile>();
        n.AddCommand<HelpCommand>();
    }) {
    protected override async Task<Result> HandleCommandAsync(CancellationToken ct = default) {
        Logger.LogInformation("Executing UserProfile command...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(ct);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], ct);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }
}

---
UserProfile\Commands\ViewUserProfile.cs
namespace Lola.UserProfile.Commands;

public class ViewUserProfile(IHasChildren parent, IUserProfileHandler handler)
    : LolaCommand<ViewUserProfile>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.ErrorText = "displaying the user profile";
        n.Description = "Display the User Profile.";
    }) {
    protected override Result HandleCommand() {
        Logger.LogInformation("Executing UserProfile->View command...");
        var user = handler.CurrentUser;
        if (user is null) {
            Logger.LogInformation("No user selected.");
            return Result.Success();
        }

        ShowDetails(user);
        return Result.Success();
    }

    private void ShowDetails(UserProfileEntity user) {
        Output.WriteLine("[yellow]User Information:[/]");
        Output.WriteLine($"[blue]Name:[/] {user.Name}");
    }
}

---
UserProfile\Handlers\IUserProfileHandler.cs
namespace Lola.UserProfile.Handlers;

public interface IUserProfileHandler {
    UserProfileEntity Create(Action<UserProfileEntity>? setUp = null);
    UserProfileEntity? CurrentUser { get; }
    void Set(UserProfileEntity user);
}

---
UserProfile\Handlers\UserProfileHandler.cs
namespace Lola.UserProfile.Handlers;

public class UserProfileHandler(IUserProfileDataSource dataSource, ILogger<UserProfileHandler> logger)
    : IUserProfileHandler {
    private UserProfileEntity? _currentUser;

    public UserProfileEntity Create(Action<UserProfileEntity>? setUp = null)
        => dataSource.Create(setUp);
    public UserProfileEntity? CurrentUser
        => _currentUser ??= dataSource.FirstOrDefault(i => !i.Internal);
    public void Set(UserProfileEntity user) {
        if (dataSource.Any()) dataSource.Update(user);
        else dataSource.Add(user);
        logger.LogInformation("User profile set.");
    }
}

---
UserProfile\Repositories\IUserProfileDataSource.cs
namespace Lola.UserProfile.Repositories;

public interface IUserProfileDataSource
    : IDataSource<UserProfileEntity, uint>;

---
UserProfile\Repositories\IUserProfileStorage.cs
namespace Lola.UserProfile.Repositories;

public interface IUserProfileStorage
    : IStorage<UserProfileEntity, uint>;

---
UserProfile\Repositories\UserProfileDataSource.cs
namespace Lola.UserProfile.Repositories;

public class UserProfileDataSource(IUserProfileStorage storage)
    : DataSource<IUserProfileStorage, UserProfileEntity, uint>(storage),
      IUserProfileDataSource;

---
UserProfile\Repositories\UserProfileEntity.cs
using AIUserProfile = DotNetToolbox.AI.Jobs.UserProfile;

namespace Lola.UserProfile.Repositories;

public class UserProfileEntity
    : Entity<UserProfileEntity, uint> {
    public bool Internal { get; init; }
    public string Name { get; set; } = string.Empty;
    public List<string> Facts { get; } = [];

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        result += ValidateName(Name);
        return result;
    }

    public static implicit operator AIUserProfile(UserProfileEntity entity)
        => new(entity.Id) {
            Name = entity.Name,
            Facts = entity.Facts,
        };

    public static Result ValidateName(string? name) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name cannot be blank.", nameof(Name));
        return result;
    }
}

---
UserProfile\Repositories\UserProfileStorage.cs
namespace Lola.UserProfile.Repositories;

public class UserProfileStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<UserProfileEntity, uint>("users", configuration),
      IUserProfileStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : LastUsedKey + 1;
        LastUsedKey = next;
        return true;
    }
}

---
Utilities\CommandHelpers.cs
namespace Lola.Utilities;

internal sealed class ListItem<TItem, TKey>(TKey key, string text, TItem? item)
    where TItem : class, IEntity<TKey>
    where TKey : notnull {
    public TKey Key { get; } = key;
    public string Text { get; } = text;
    public TItem? Item { get; } = item;
}

public static class CommandHelpers {
    public static async Task<TItem?> SelectEntityAsync<TItem, TKey>(this ICommand command,
                                                                    IEnumerable<TItem> entities,
                                                                    Func<TItem, string> mapText,
                                                                    CancellationToken ct = default)
        where TItem : class, IEntity<TKey>
        where TKey : notnull {
        var items = IsNotNull(entities).ToArray();
        if (items.Length == 0) {
            command.Output.WriteLine("[yellow]No items found.[/]");
            return null;
        }

        var choices = items.ToList(e => new ListItem<TItem, TKey>(e.Id, IsNotNull(mapText)(e), e));
        var cancelOption = new ListItem<TItem, TKey>(default!, "Cancel", null);
        choices.Add(cancelOption);

        const string prompt = "Select an item or cancel to return:";
        return (await command.Input.BuildSelectionPrompt<ListItem<TItem, TKey>>(prompt)
                                   .AddChoices([.. choices])
                                   .ConvertWith(e => e.Item is null ? $"[yellow bold]{e.Text}[/]" : e.Text)
                                   .ShowAsync(ct)).Item;
    }
}

---
Utilities\EncryptionHelper.cs
namespace Lola.Utilities;

public interface IEncryptionHelper {
    string? Encrypt(string? plainText);
    string? Decrypt(string? cipherText);
}

public sealed class EncryptionHelper : IEncryptionHelper {
    private static IEncryptionHelper? _instance;
    private readonly byte[] _secretKey;
    private readonly byte[] _initVector;

    private EncryptionHelper(IConfiguration configuration) {
        _secretKey = Convert.FromBase64String(IsNotNull(configuration["Encryption:SecretKey"]));
        _initVector = Convert.FromBase64String(IsNotNull(configuration["Encryption:InitVector"]));
    }

    public static void Initialize(IConfiguration configuration) {
        if (_instance != null) return;
        _instance = new EncryptionHelper(configuration);
    }

    public static IEncryptionHelper Instance
        => _instance
        ?? throw new InvalidOperationException("EncryptionHelper has not been initialized.");

    public string? Encrypt(string? plainText) {
        if (plainText is null) return null;
        if (plainText.Length == 0) return string.Empty;
        using var aesAlg = Aes.Create();
        aesAlg.Key = _secretKey;
        aesAlg.IV = _initVector;

        var encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

        using var msEncrypt = new MemoryStream();
        using var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        using var swEncrypt = new StreamWriter(csEncrypt);
        swEncrypt.Write(plainText);

        return Convert.ToBase64String(msEncrypt.ToArray());
    }

    public string? Decrypt(string? cipherText) {
        try {
            if (cipherText is null) return null;
            if (cipherText.Length == 0) return string.Empty;
            var cipherBytes = Convert.FromBase64String(cipherText);

            using var aesAlg = Aes.Create();
            aesAlg.Key = _secretKey;
            aesAlg.IV = _initVector;

            var decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using var msDecrypt = new MemoryStream(cipherBytes);
            using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            using var srDecrypt = new StreamReader(csDecrypt);

            return srDecrypt.ReadToEnd();
        }
        catch (FormatException) {
            return null;
        }
    }
}

---
Utilities\JsonSchemaGenerator.cs
namespace Lola.Utilities;

public static class JsonSchemaGenerator {
    public static string GenerateSchemaFor<T>()
        where T : class
        => GenerateSchema(typeof(T));

    private static readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    public static string GenerateSchema(Type type) {
        var schema = new Dictionary<string, object> {
            ["$schema"] = "https://json-schema.org/draft/2020-12/schema",
            ["type"] = GetJsonType(type)
        };

        if (GetJsonType(type) == "object") {
            schema["properties"] = GenerateProperties(type);
            var requiredProperties = GetRequiredProperties(type);
            if (requiredProperties.Count != 0) {
                schema["required"] = requiredProperties;
            }
        }
        else if (GetJsonType(type) == "array") {
            schema["items"] = GenerateArrayItems(type);
        }

        return JsonSerializer.Serialize(schema, _jsonOptions);
    }

    private static Dictionary<string, object> GenerateArrayItems(Type type) {
        var elementType = type.GetElementType() ?? type.GetGenericArguments().FirstOrDefault();
        return elementType == null
            ? new() { ["type"] = "object" }
            : GenerateSchemaForType(elementType);
    }

    private static string GetJsonType(Type type) => type switch {
        not null when type == typeof(string) => "string",
        not null when type == typeof(DateTime)
                   || type == typeof(DateTimeOffset)
                   || type == typeof(TimeSpan)
                   || type == typeof(Guid)
                   || type == typeof(Uri)
                   || type == typeof(Version) => "string",
        not null when type.IsEnum => "string",
        not null when type == typeof(int)
                   || type == typeof(long)
                   || type == typeof(float)
                   || type == typeof(double)
                   || type == typeof(decimal)
                   || type == typeof(short)
                   || type == typeof(ushort)
                   || type == typeof(uint)
                   || type == typeof(ulong)
                   || type == typeof(byte)
                   || type == typeof(sbyte) => "number",
        not null when type == typeof(bool) => "boolean",
        not null when type.IsArray
                   || (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(List<>)
                                           || type.GetGenericTypeDefinition() == typeof(IEnumerable<>))) => "array",
        not null when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) => GetJsonType(Nullable.GetUnderlyingType(type)!),
        not null when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<,>) => "object",
        _ => "object",
    };
    private static Dictionary<string, object> GenerateProperties(Type type) {
        var properties = new Dictionary<string, object>();

        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)) {
            properties[prop.Name] = GenerateSchemaForType(prop.PropertyType);
            AddAttributeInfo((Dictionary<string, object>)properties[prop.Name], prop);
        }

        return properties;
    }

    private static Dictionary<string, object> GenerateSchemaForType(Type type) {
        var schema = new Dictionary<string, object> {
            ["type"] = GetJsonType(type)
        };

        if (type.IsEnum) {
            schema["enum"] = Enum.GetNames(type);
        }
        else if (GetJsonType(type) == "object") {
            schema["properties"] = GenerateProperties(type);
            var requiredProperties = GetRequiredProperties(type);
            if (requiredProperties.Count != 0) {
                schema["required"] = requiredProperties;
            }
        }
        else if (GetJsonType(type) == "array") {
            schema["items"] = GenerateArrayItems(type);
        }

        return schema;
    }

    private static void AddAttributeInfo(Dictionary<string, object> schema, PropertyInfo prop) {
        var descriptionAttribute = prop.GetCustomAttribute<DescriptionAttribute>();
        if (descriptionAttribute != null) {
            schema["description"] = descriptionAttribute.Description;
        }

        if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTimeOffset)) {
            schema["format"] = "date-time";
        }
        else if (prop.PropertyType == typeof(Guid)) {
            schema["format"] = "uuid";
        }

        var rangeAttribute = prop.GetCustomAttribute<RangeAttribute>();
        if (rangeAttribute != null) {
            schema["minimum"] = rangeAttribute.Minimum;
            schema["maximum"] = rangeAttribute.Maximum;
        }

        var stringLengthAttribute = prop.GetCustomAttribute<StringLengthAttribute>();
        if (stringLengthAttribute != null) {
            if (stringLengthAttribute.MinimumLength > 0)
                schema["minLength"] = stringLengthAttribute.MinimumLength;
            schema["maxLength"] = stringLengthAttribute.MaximumLength;
        }

        var regexAttribute = prop.GetCustomAttribute<RegularExpressionAttribute>();
        if (regexAttribute != null) {
            schema["pattern"] = regexAttribute.Pattern;
        }
    }

    private static List<string> GetRequiredProperties(Type type)
        => type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
               .Where(p => (Nullable.GetUnderlyingType(p.PropertyType) == null
                        && p.PropertyType.IsValueType
                     && !IsNullableReferenceType(p))
                     || p.GetCustomAttribute<RequiredAttribute>() != null)
            .Select(p => p.Name)
            .ToList();

    private static bool IsNullableReferenceType(PropertyInfo prop)
        => !prop.PropertyType.IsValueType &&
            prop.GetCustomAttribute<NullableAttribute>()?.NullableFlags[0] == 2;
}

---
Utilities\HttpConnection\Handlers\HttpConnectionHandler.cs
namespace Lola.Utilities.HttpConnection.Handlers;

public class HttpConnectionHandler(IModelHandler modelHandler, IAgentAccessor httpConnectionAccessor)
    : IHttpConnectionHandler {
    public IAgent GetInternal() {
        var model = modelHandler.Selected ?? throw new InvalidOperationException("No internal model found.");
        return httpConnectionAccessor.GetFor(model.Provider!.Name);
    }

    public IAgent Get(string modelKey) {
        var model = modelHandler.Find(m => m.Key == modelKey) ?? throw new InvalidOperationException("Model not found.");
        return httpConnectionAccessor.GetFor(model.Provider!.Name);
    }
}

---
Utilities\HttpConnection\Handlers\IHttpConnectionHandler.cs
namespace Lola.Utilities.HttpConnection.Handlers;

public interface IHttpConnectionHandler {
    IAgent GetInternal();
    IAgent Get(string modelKey);
}

